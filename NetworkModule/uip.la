   1                     ; C Compiler for STM8 (COSMIC Software)
   2                     ; Parser V4.11.14 - 18 Nov 2019
   3                     ; Generator (Limited) V4.4.11 - 19 Nov 2019
   4                     ; Optimizer V4.4.11 - 19 Nov 2019
  18                     	switch	.data
  19  000a               _uip_ethaddr:
  20  000a 01            	dc.b	1
  21  000b 02            	dc.b	2
  22  000c 03            	dc.b	3
  23  000d 04            	dc.b	4
  24  000e 05            	dc.b	5
  25  000f 06            	dc.b	6
  64                     ; 176 void uip_setipid(uint16_t id)
  64                     ; 177 {
  66                     .text:	section	.text,new
  67                     _uip_setipid:
  71                     ; 178   ipid = id;
  73                     	ldw	L11_ipid,x
  74                     ; 179 }
  77                     	ret	
 120                     ; 230 void uip_add32(uint8_t *op32, uint16_t op16)
 120                     ; 231 {
 121                     .text:	section	.text,new
 122  e6d7               _uip_add32:
 124  e6d7 89            	pushw	x
 125  e6d8 89            	pushw	x
 126       00000002      OFST:	set	2
 129                     ; 232   uip_acc32[3] = (uint8_t)(op32[3] + (op16 & 0xff));
 131  e6d9 7b08          	ld	a,(OFST+6,sp)
 132  e6db eb03          	add	a,(3,x)
 133  e6dd c702cc        	ld	_uip_acc32+3,a
 134                     ; 233   uip_acc32[2] = (uint8_t)(op32[2] + (op16 >> 8));
 136  e6e0 e602          	ld	a,(2,x)
 137  e6e2 1b07          	add	a,(OFST+5,sp)
 138  e6e4 c702cb        	ld	_uip_acc32+2,a
 139                     ; 234   uip_acc32[1] = op32[1];
 141  e6e7 e601          	ld	a,(1,x)
 142  e6e9 c702ca        	ld	_uip_acc32+1,a
 143                     ; 235   uip_acc32[0] = op32[0];
 145  e6ec f6            	ld	a,(x)
 146  e6ed c702c9        	ld	_uip_acc32,a
 147                     ; 237   if (uip_acc32[2] < (op16 >> 8)) {
 149  e6f0 4f            	clr	a
 150  e6f1 1e07          	ldw	x,(OFST+5,sp)
 151  e6f3 01            	rrwa	x,a
 152  e6f4 c602cb        	ld	a,_uip_acc32+2
 153  e6f7 905f          	clrw	y
 154  e6f9 9097          	ld	yl,a
 155  e6fb 90bf07        	ldw	c_y,y
 156  e6fe b307          	cpw	x,c_y
 157  e700 230a          	jrule	L56
 158                     ; 238     ++uip_acc32[1];
 160  e702 725c02ca      	inc	_uip_acc32+1
 161                     ; 239     if (uip_acc32[1] == 0) {
 163  e706 2604          	jrne	L56
 164                     ; 240       ++uip_acc32[0];
 166  e708 725c02c9      	inc	_uip_acc32
 167  e70c               L56:
 168                     ; 244   if (uip_acc32[3] < (op16 & 0xff)) {
 170  e70c c602cc        	ld	a,_uip_acc32+3
 171  e70f 5f            	clrw	x
 172  e710 97            	ld	xl,a
 173  e711 1f01          	ldw	(OFST-1,sp),x
 175  e713 5f            	clrw	x
 176  e714 7b08          	ld	a,(OFST+6,sp)
 177  e716 02            	rlwa	x,a
 178  e717 1301          	cpw	x,(OFST-1,sp)
 179  e719 2310          	jrule	L17
 180                     ; 245     ++uip_acc32[2];
 182  e71b 725c02cb      	inc	_uip_acc32+2
 183                     ; 246     if (uip_acc32[2] == 0) {
 185  e71f 260a          	jrne	L17
 186                     ; 247       ++uip_acc32[1];
 188  e721 725c02ca      	inc	_uip_acc32+1
 189                     ; 248       if (uip_acc32[1] == 0) {
 191  e725 2604          	jrne	L17
 192                     ; 249         ++uip_acc32[0];
 194  e727 725c02c9      	inc	_uip_acc32
 195  e72b               L17:
 196                     ; 253 }
 199  e72b 5b04          	addw	sp,#4
 200  e72d 81            	ret	
 276                     ; 260 static uint16_t chksum(uint16_t sum, const uint8_t *data, uint16_t len)
 276                     ; 261 {
 277                     .text:	section	.text,new
 278  e72e               L77_chksum:
 280  e72e 89            	pushw	x
 281  e72f 5206          	subw	sp,#6
 282       00000006      OFST:	set	6
 285                     ; 266   dataptr = data;
 287  e731 1e0b          	ldw	x,(OFST+5,sp)
 288  e733 1f05          	ldw	(OFST-1,sp),x
 290                     ; 267   last_byte = data + len - 1;
 292  e735 72fb0d        	addw	x,(OFST+7,sp)
 293  e738 5a            	decw	x
 294  e739 1f01          	ldw	(OFST-5,sp),x
 297  e73b 1e05          	ldw	x,(OFST-1,sp)
 298  e73d 2020          	jra	L141
 299  e73f               L531:
 300                     ; 270     t = (dataptr[0] << 8) + dataptr[1];
 302  e73f f6            	ld	a,(x)
 303  e740 5f            	clrw	x
 304  e741 97            	ld	xl,a
 305  e742 1605          	ldw	y,(OFST-1,sp)
 306  e744 4f            	clr	a
 307  e745 90eb01        	add	a,(1,y)
 308  e748 2401          	jrnc	L21
 309  e74a 5c            	incw	x
 310  e74b               L21:
 311  e74b 02            	rlwa	x,a
 312  e74c 1f03          	ldw	(OFST-3,sp),x
 314                     ; 271     sum += t;
 316  e74e 72fb07        	addw	x,(OFST+1,sp)
 317                     ; 272     if (sum < t) sum++; /* carry */
 319  e751 1303          	cpw	x,(OFST-3,sp)
 320  e753 2401          	jruge	L541
 323  e755 5c            	incw	x
 324  e756               L541:
 325  e756 1f07          	ldw	(OFST+1,sp),x
 326                     ; 273     dataptr += 2;
 328  e758 1e05          	ldw	x,(OFST-1,sp)
 329  e75a 1c0002        	addw	x,#2
 330  e75d 1f05          	ldw	(OFST-1,sp),x
 332  e75f               L141:
 333                     ; 269   while (dataptr < last_byte) { /* At least two more bytes */
 335  e75f 1301          	cpw	x,(OFST-5,sp)
 336  e761 25dc          	jrult	L531
 337                     ; 276   if (dataptr == last_byte) {
 339  e763 2612          	jrne	L741
 340                     ; 277     t = (dataptr[0] << 8) + 0;
 342  e765 f6            	ld	a,(x)
 343  e766 97            	ld	xl,a
 344  e767 4f            	clr	a
 345  e768 02            	rlwa	x,a
 346  e769 1f03          	ldw	(OFST-3,sp),x
 348                     ; 278     sum += t;
 350  e76b 72fb07        	addw	x,(OFST+1,sp)
 351  e76e 1f07          	ldw	(OFST+1,sp),x
 352                     ; 279     if (sum < t) sum++; /* carry */
 354  e770 1303          	cpw	x,(OFST-3,sp)
 355  e772 2403          	jruge	L741
 358  e774 5c            	incw	x
 359  e775 1f07          	ldw	(OFST+1,sp),x
 360  e777               L741:
 361                     ; 282   return sum;
 363  e777 1e07          	ldw	x,(OFST+1,sp)
 366  e779 5b08          	addw	sp,#8
 367  e77b 81            	ret	
 411                     ; 287 uint16_t uip_chksum(uint16_t *data, uint16_t len)
 411                     ; 288 {
 412                     .text:	section	.text,new
 413                     _uip_chksum:
 415                     	pushw	x
 416       00000000      OFST:	set	0
 419                     ; 289   return htons(chksum(0, (uint8_t *)data, len));
 421                     	ldw	x,(OFST+5,sp)
 422                     	pushw	x
 423                     	ldw	x,(OFST+3,sp)
 424                     	pushw	x
 425                     	clrw	x
 426                     	call	L77_chksum
 428                     	addw	sp,#4
 429                     	call	_htons
 433                     	addw	sp,#2
 434                     	ret	
 469                     ; 295 uint16_t uip_ipchksum(void)
 469                     ; 296 {
 470                     .text:	section	.text,new
 471  e77c               _uip_ipchksum:
 473  e77c 89            	pushw	x
 474       00000002      OFST:	set	2
 477                     ; 299   sum = chksum(0, &uip_buf[UIP_LLH_LEN], UIP_IPH_LEN);
 479  e77d ae0014        	ldw	x,#20
 480  e780 89            	pushw	x
 481  e781 ae0385        	ldw	x,#_uip_buf+14
 482  e784 89            	pushw	x
 483  e785 5f            	clrw	x
 484  e786 cde72e        	call	L77_chksum
 486  e789 5b04          	addw	sp,#4
 487  e78b 1f01          	ldw	(OFST-1,sp),x
 489                     ; 301   return (sum == 0) ? 0xffff : htons(sum);
 491  e78d 2603          	jrne	L62
 492  e78f 5a            	decw	x
 493  e790 2003          	jra	L03
 494  e792               L62:
 495  e792 cdf225        	call	_htons
 497  e795               L03:
 500  e795 5b02          	addw	sp,#2
 501  e797 81            	ret	
 550                     ; 307 static uint16_t upper_layer_chksum(uint8_t proto)
 550                     ; 308 {
 551                     .text:	section	.text,new
 552  e798               L702_upper_layer_chksum:
 554  e798 88            	push	a
 555  e799 5204          	subw	sp,#4
 556       00000004      OFST:	set	4
 559                     ; 312   upper_layer_len = (((uint16_t)(BUF->len[0]) << 8) + BUF->len[1]) - UIP_IPH_LEN;
 561  e79b c60387        	ld	a,_uip_buf+16
 562  e79e 5f            	clrw	x
 563  e79f 97            	ld	xl,a
 564  e7a0 4f            	clr	a
 565  e7a1 cb0388        	add	a,_uip_buf+17
 566  e7a4 2401          	jrnc	L63
 567  e7a6 5c            	incw	x
 568  e7a7               L63:
 569  e7a7 02            	rlwa	x,a
 570  e7a8 1d0014        	subw	x,#20
 571  e7ab 1f01          	ldw	(OFST-3,sp),x
 573                     ; 317   sum = upper_layer_len + proto;
 575  e7ad 5f            	clrw	x
 576  e7ae 7b05          	ld	a,(OFST+1,sp)
 577  e7b0 97            	ld	xl,a
 578  e7b1 72fb01        	addw	x,(OFST-3,sp)
 579  e7b4 1f03          	ldw	(OFST-1,sp),x
 581                     ; 319   sum = chksum(sum, (uint8_t *)&BUF->srcipaddr[0], 2 * sizeof(uip_ipaddr_t));
 583  e7b6 ae0008        	ldw	x,#8
 584  e7b9 89            	pushw	x
 585  e7ba ae0391        	ldw	x,#_uip_buf+26
 586  e7bd 89            	pushw	x
 587  e7be 1e07          	ldw	x,(OFST+3,sp)
 588  e7c0 cde72e        	call	L77_chksum
 590  e7c3 5b04          	addw	sp,#4
 591  e7c5 1f03          	ldw	(OFST-1,sp),x
 593                     ; 322   sum = chksum(sum, &uip_buf[UIP_IPH_LEN + UIP_LLH_LEN], upper_layer_len);
 595  e7c7 1e01          	ldw	x,(OFST-3,sp)
 596  e7c9 89            	pushw	x
 597  e7ca ae0399        	ldw	x,#_uip_buf+34
 598  e7cd 89            	pushw	x
 599  e7ce 1e07          	ldw	x,(OFST+3,sp)
 600  e7d0 cde72e        	call	L77_chksum
 602  e7d3 5b04          	addw	sp,#4
 603  e7d5 1f03          	ldw	(OFST-1,sp),x
 605                     ; 324   return (sum == 0) ? 0xffff : htons(sum);
 607  e7d7 2603          	jrne	L44
 608  e7d9 5a            	decw	x
 609  e7da 2003          	jra	L64
 610  e7dc               L44:
 611  e7dc cdf225        	call	_htons
 613  e7df               L64:
 616  e7df 5b05          	addw	sp,#5
 617  e7e1 81            	ret	
 641                     ; 329 uint16_t uip_tcpchksum(void)
 641                     ; 330 {
 642                     .text:	section	.text,new
 643  e7e2               _uip_tcpchksum:
 647                     ; 331   return upper_layer_chksum(UIP_PROTO_TCP);
 649  e7e2 a606          	ld	a,#6
 653  e7e4 cce798        	jp	L702_upper_layer_chksum
 679                     ; 337 void uip_init(void)
 679                     ; 338 {
 680                     .text:	section	.text,new
 681  e7e7               _uip_init:
 685                     ; 339   for (c = 0; c < UIP_LISTENPORTS; ++c) uip_listenports[c] = 0;
 687  e7e7 4f            	clr	a
 688  e7e8 c702a5        	ld	L73_c,a
 689  e7eb               L152:
 692  e7eb 5f            	clrw	x
 693  e7ec 97            	ld	xl,a
 694  e7ed 58            	sllw	x
 695  e7ee 905f          	clrw	y
 696  e7f0 df02ac        	ldw	(_uip_listenports,x),y
 699  e7f3 725c02a5      	inc	L73_c
 702  e7f7 c602a5        	ld	a,L73_c
 703  e7fa a104          	cp	a,#4
 704  e7fc 25ed          	jrult	L152
 705                     ; 340   for (c = 0; c < UIP_CONNS; ++c) uip_conns[c].tcpstateflags = UIP_CLOSED;
 707  e7fe 4f            	clr	a
 708  e7ff c702a5        	ld	L73_c,a
 709  e802               L752:
 712  e802 97            	ld	xl,a
 713  e803 a629          	ld	a,#41
 714  e805 42            	mul	x,a
 715  e806 724f02e6      	clr	(_uip_conns+25,x)
 718  e80a 725c02a5      	inc	L73_c
 721  e80e c602a5        	ld	a,L73_c
 722  e811 a104          	cp	a,#4
 723  e813 25ed          	jrult	L752
 724                     ; 347 }
 727  e815 81            	ret	
1028                     ; 357 struct uip_conn *
1028                     ; 358 uip_connect(uip_ipaddr_t *ripaddr, uint16_t rport, uint16_t lport)
1028                     ; 359 {
1029                     .text:	section	.text,new
1030  e816               _uip_connect:
1032  e816 89            	pushw	x
1033  e817 5204          	subw	sp,#4
1034       00000004      OFST:	set	4
1037                     ; 363   conn = 0;
1039  e819 5f            	clrw	x
1040  e81a 1f03          	ldw	(OFST-1,sp),x
1042                     ; 364   for(c = 0; c < UIP_CONNS; ++c) {
1044  e81c 4f            	clr	a
1045  e81d c702a5        	ld	L73_c,a
1046  e820               L144:
1047                     ; 365     cconn = &uip_conns[c];
1049  e820 97            	ld	xl,a
1050  e821 a629          	ld	a,#41
1051  e823 42            	mul	x,a
1052  e824 1c02cd        	addw	x,#_uip_conns
1053  e827 1f01          	ldw	(OFST-3,sp),x
1055                     ; 366     if(cconn->tcpstateflags == UIP_CLOSED) {
1057  e829 e619          	ld	a,(25,x)
1058  e82b 2604          	jrne	L744
1059                     ; 367       conn = cconn;
1061  e82d 1f03          	ldw	(OFST-1,sp),x
1063                     ; 368       break;
1065  e82f 2021          	jra	L544
1066  e831               L744:
1067                     ; 370     if(cconn->tcpstateflags == UIP_TIME_WAIT) {
1069  e831 a107          	cp	a,#7
1070  e833 2612          	jrne	L154
1071                     ; 371       if(conn == 0 ||
1071                     ; 372 	 cconn->timer > conn->timer) {
1073  e835 1e03          	ldw	x,(OFST-1,sp)
1074  e837 270a          	jreq	L554
1076  e839 1e01          	ldw	x,(OFST-3,sp)
1077  e83b e61a          	ld	a,(26,x)
1078  e83d 1e03          	ldw	x,(OFST-1,sp)
1079  e83f e11a          	cp	a,(26,x)
1080  e841 2304          	jrule	L154
1081  e843               L554:
1082                     ; 373 	conn = cconn;
1084  e843 1e01          	ldw	x,(OFST-3,sp)
1085  e845 1f03          	ldw	(OFST-1,sp),x
1087  e847               L154:
1088                     ; 364   for(c = 0; c < UIP_CONNS; ++c) {
1090  e847 725c02a5      	inc	L73_c
1093  e84b c602a5        	ld	a,L73_c
1094  e84e a104          	cp	a,#4
1095  e850 25ce          	jrult	L144
1096  e852               L544:
1097                     ; 378   if(conn == 0) return 0;
1099  e852 1e03          	ldw	x,(OFST-1,sp)
1100  e854 2603          	jrne	L754
1103  e856 5f            	clrw	x
1105  e857 2053          	jra	L26
1106  e859               L754:
1107                     ; 380   conn->tcpstateflags = UIP_SYN_SENT;
1109  e859 a602          	ld	a,#2
1110  e85b e719          	ld	(25,x),a
1111                     ; 382   conn->snd_nxt[0] = iss[0];
1113  e85d c602a6        	ld	a,L53_iss
1114  e860 e70c          	ld	(12,x),a
1115                     ; 383   conn->snd_nxt[1] = iss[1];
1117  e862 c602a7        	ld	a,L53_iss+1
1118  e865 e70d          	ld	(13,x),a
1119                     ; 384   conn->snd_nxt[2] = iss[2];
1121  e867 c602a8        	ld	a,L53_iss+2
1122  e86a e70e          	ld	(14,x),a
1123                     ; 385   conn->snd_nxt[3] = iss[3];
1125  e86c c602a9        	ld	a,L53_iss+3
1126  e86f e70f          	ld	(15,x),a
1127                     ; 387   conn->initialmss = conn->mss = UIP_TCP_MSS;
1129  e871 90ae01b8      	ldw	y,#440
1130  e875 ef12          	ldw	(18,x),y
1131  e877 1603          	ldw	y,(OFST-1,sp)
1132  e879 ee12          	ldw	x,(18,x)
1133  e87b 90ef14        	ldw	(20,y),x
1134                     ; 389   conn->len = 1;   /* TCP length of the SYN is one. */
1136  e87e 93            	ldw	x,y
1137  e87f 90ae0001      	ldw	y,#1
1138  e883 ef10          	ldw	(16,x),y
1139                     ; 390   conn->nrtx = 0;
1141  e885 6f1b          	clr	(27,x)
1142                     ; 391   conn->timer = 1; /* Send the SYN next time around. */
1144  e887 a601          	ld	a,#1
1145  e889 e71a          	ld	(26,x),a
1146                     ; 392   conn->rto = UIP_RTO;
1148  e88b a603          	ld	a,#3
1149  e88d e718          	ld	(24,x),a
1150                     ; 393   conn->sa = 0;
1152  e88f 6f16          	clr	(22,x)
1153                     ; 394   conn->sv = 16;   /* Initial value of the RTT variance. */
1155  e891 a610          	ld	a,#16
1156  e893 e717          	ld	(23,x),a
1157                     ; 395   conn->lport = lport;
1159  e895 160b          	ldw	y,(OFST+7,sp)
1160  e897 ef04          	ldw	(4,x),y
1161                     ; 396   conn->rport = rport;
1163  e899 1609          	ldw	y,(OFST+5,sp)
1164  e89b ef06          	ldw	(6,x),y
1165                     ; 397   uip_ipaddr_copy(&conn->ripaddr, ripaddr);
1167  e89d 1e05          	ldw	x,(OFST+1,sp)
1168  e89f 1603          	ldw	y,(OFST-1,sp)
1169  e8a1 fe            	ldw	x,(x)
1170  e8a2 90ff          	ldw	(y),x
1173  e8a4 1e05          	ldw	x,(OFST+1,sp)
1174  e8a6 ee02          	ldw	x,(2,x)
1175  e8a8 90ef02        	ldw	(2,y),x
1176                     ; 398   return conn;
1178  e8ab 93            	ldw	x,y
1180  e8ac               L26:
1182  e8ac 5b06          	addw	sp,#6
1183  e8ae 81            	ret	
1206                     ; 404 void uip_init_stats(void)
1206                     ; 405 {
1207                     .text:	section	.text,new
1208  e8af               _uip_init_stats:
1212                     ; 431 }
1215  e8af 81            	ret	
1249                     ; 435 void uip_unlisten(uint16_t port)
1249                     ; 436 {
1250                     .text:	section	.text,new
1251                     _uip_unlisten:
1253                     	pushw	x
1254       00000000      OFST:	set	0
1257                     ; 437   for (c = 0; c < UIP_LISTENPORTS; ++c) {
1259                     	clr	a
1260                     	ld	L73_c,a
1261                     L115:
1262                     ; 438     if (uip_listenports[c] == port) {
1264                     	clrw	x
1265                     	ld	xl,a
1266                     	sllw	x
1267                     	ldw	x,(_uip_listenports,x)
1268                     	cpw	x,(OFST+1,sp)
1269                     	jrne	L715
1270                     ; 439       uip_listenports[c] = 0;
1272                     	clrw	x
1273                     	ld	xl,a
1274                     	sllw	x
1275                     	clrw	y
1276                     	ldw	(_uip_listenports,x),y
1277                     ; 440       return;
1279                     	jra	L07
1280                     L715:
1281                     ; 437   for (c = 0; c < UIP_LISTENPORTS; ++c) {
1283                     	inc	L73_c
1286                     	ld	a,L73_c
1287                     	cp	a,#4
1288                     	jrult	L115
1289                     ; 443 }
1290                     L07:
1293                     	popw	x
1294                     	ret	
1328                     ; 447 void uip_listen(uint16_t port)
1328                     ; 448 {
1329                     .text:	section	.text,new
1330  e8b0               _uip_listen:
1332  e8b0 89            	pushw	x
1333       00000000      OFST:	set	0
1336                     ; 449   for (c = 0; c < UIP_LISTENPORTS; ++c) {
1338  e8b1 4f            	clr	a
1339  e8b2 c702a5        	ld	L73_c,a
1340  e8b5               L535:
1341                     ; 450     if (uip_listenports[c] == 0) {
1343  e8b5 5f            	clrw	x
1344  e8b6 97            	ld	xl,a
1345  e8b7 58            	sllw	x
1346  e8b8 d602ad        	ld	a,(_uip_listenports+1,x)
1347  e8bb da02ac        	or	a,(_uip_listenports,x)
1348  e8be 2607          	jrne	L345
1349                     ; 451       uip_listenports[c] = port;
1351  e8c0 1601          	ldw	y,(OFST+1,sp)
1352  e8c2 df02ac        	ldw	(_uip_listenports,x),y
1353                     ; 452       return;
1355  e8c5 200b          	jra	L47
1356  e8c7               L345:
1357                     ; 449   for (c = 0; c < UIP_LISTENPORTS; ++c) {
1359  e8c7 725c02a5      	inc	L73_c
1362  e8cb c602a5        	ld	a,L73_c
1363  e8ce a104          	cp	a,#4
1364  e8d0 25e3          	jrult	L535
1365                     ; 455 }
1366  e8d2               L47:
1369  e8d2 85            	popw	x
1370  e8d3 81            	ret	
1405                     ; 459 static void uip_add_rcv_nxt(uint16_t n)
1405                     ; 460 {
1406                     .text:	section	.text,new
1407  e8d4               L545_uip_add_rcv_nxt:
1411                     ; 461   uip_add32(uip_conn->rcv_nxt, n);
1413  e8d4 89            	pushw	x
1414  e8d5 ce0371        	ldw	x,_uip_conn
1415  e8d8 1c0008        	addw	x,#8
1416  e8db cde6d7        	call	_uip_add32
1418  e8de 85            	popw	x
1419                     ; 462   uip_conn->rcv_nxt[0] = uip_acc32[0];
1421  e8df ce0371        	ldw	x,_uip_conn
1422  e8e2 c602c9        	ld	a,_uip_acc32
1423  e8e5 e708          	ld	(8,x),a
1424                     ; 463   uip_conn->rcv_nxt[1] = uip_acc32[1];
1426  e8e7 c602ca        	ld	a,_uip_acc32+1
1427  e8ea e709          	ld	(9,x),a
1428                     ; 464   uip_conn->rcv_nxt[2] = uip_acc32[2];
1430  e8ec c602cb        	ld	a,_uip_acc32+2
1431  e8ef e70a          	ld	(10,x),a
1432                     ; 465   uip_conn->rcv_nxt[3] = uip_acc32[3];
1434  e8f1 c602cc        	ld	a,_uip_acc32+3
1435  e8f4 e70b          	ld	(11,x),a
1436                     ; 466 }
1439  e8f6 81            	ret	
1511                     ; 470 void uip_process(uint8_t flag)
1511                     ; 471 {
1512                     .text:	section	.text,new
1513  e8f7               _uip_process:
1515  e8f7 88            	push	a
1516  e8f8 5205          	subw	sp,#5
1517       00000005      OFST:	set	5
1520                     ; 472   register struct uip_conn *uip_connr = uip_conn;
1522  e8fa ce0371        	ldw	x,_uip_conn
1523  e8fd 1f04          	ldw	(OFST-1,sp),x
1525                     ; 486   uip_sappdata = uip_appdata = &uip_buf[UIP_IPTCPH_LEN + UIP_LLH_LEN];
1527  e8ff ae03ad        	ldw	x,#_uip_buf+54
1528  e902 cf0375        	ldw	_uip_appdata,x
1529  e905 cf02b6        	ldw	_uip_sappdata,x
1530                     ; 491   if (flag == UIP_POLL_REQUEST) {
1532  e908 a103          	cp	a,#3
1533  e90a 2614          	jrne	L107
1534                     ; 492     if ((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_ESTABLISHED && !uip_outstanding(uip_connr)) {
1536  e90c 1e04          	ldw	x,(OFST-1,sp)
1537  e90e e619          	ld	a,(25,x)
1538  e910 a40f          	and	a,#15
1539  e912 a103          	cp	a,#3
1540  e914 2703ccf21a    	jrne	L356
1542  e919 e611          	ld	a,(17,x)
1543  e91b ea10          	or	a,(16,x)
1544                     ; 493       uip_flags = UIP_POLL;
1545                     ; 494       UIP_APPCALL(); // Check for any data to be sent
1547                     ; 495       goto appsend;
1549  e91d cce9e9        	jp	LC001
1550  e920               L107:
1551                     ; 503   else if (flag == UIP_TIMER) {
1553  e920 7b06          	ld	a,(OFST+1,sp)
1554  e922 a102          	cp	a,#2
1555  e924 2703ccea09    	jrne	L507
1556                     ; 505     if (++iss[3] == 0) {
1558  e929 725c02a9      	inc	L53_iss+3
1559  e92d 2610          	jrne	L117
1560                     ; 506       if (++iss[2] == 0) {
1562  e92f 725c02a8      	inc	L53_iss+2
1563  e933 260a          	jrne	L117
1564                     ; 507         if (++iss[1] == 0) {
1566  e935 725c02a7      	inc	L53_iss+1
1567  e939 2604          	jrne	L117
1568                     ; 508           ++iss[0];
1570  e93b 725c02a6      	inc	L53_iss
1571  e93f               L117:
1572                     ; 514     uip_len = 0;
1574  e93f 5f            	clrw	x
1575  e940 cf0373        	ldw	_uip_len,x
1576                     ; 515     uip_slen = 0;
1578  e943 cf02b4        	ldw	_uip_slen,x
1579                     ; 520     if (uip_connr->tcpstateflags == UIP_TIME_WAIT || uip_connr->tcpstateflags == UIP_FIN_WAIT_2) {
1581  e946 1e04          	ldw	x,(OFST-1,sp)
1582  e948 e619          	ld	a,(25,x)
1583  e94a a107          	cp	a,#7
1584  e94c 2704          	jreq	L127
1586  e94e a105          	cp	a,#5
1587  e950 260d          	jrne	L717
1588  e952               L127:
1589                     ; 521       ++(uip_connr->timer);
1591  e952 6c1a          	inc	(26,x)
1592                     ; 522       if (uip_connr->timer == UIP_TIME_WAIT_TIMEOUT) {
1594  e954 e61a          	ld	a,(26,x)
1595  e956 a178          	cp	a,#120
1596  e958 26bc          	jrne	L356
1597                     ; 523         uip_connr->tcpstateflags = UIP_CLOSED;
1599  e95a 6f19          	clr	(25,x)
1600  e95c ccf21a        	jra	L356
1601  e95f               L717:
1602                     ; 526     else if (uip_connr->tcpstateflags != UIP_CLOSED) {
1604  e95f e619          	ld	a,(25,x)
1605  e961 27f9          	jreq	L356
1606                     ; 530       if (uip_outstanding(uip_connr)) {
1608  e963 e611          	ld	a,(17,x)
1609  e965 ea10          	or	a,(16,x)
1610  e967 277a          	jreq	L137
1611                     ; 531         if (uip_connr->timer-- == 0) {
1613  e969 e61a          	ld	a,(26,x)
1614  e96b 6a1a          	dec	(26,x)
1615  e96d 4d            	tnz	a
1616  e96e 26ec          	jrne	L356
1617                     ; 532           if (uip_connr->nrtx == UIP_MAXRTX
1617                     ; 533 	    || ((uip_connr->tcpstateflags == UIP_SYN_SENT
1617                     ; 534             || uip_connr->tcpstateflags == UIP_SYN_RCVD)
1617                     ; 535             && uip_connr->nrtx == UIP_MAXSYNRTX)) {
1619  e970 e61b          	ld	a,(27,x)
1620  e972 a108          	cp	a,#8
1621  e974 270f          	jreq	L737
1623  e976 e619          	ld	a,(25,x)
1624  e978 a102          	cp	a,#2
1625  e97a 2703          	jreq	L147
1627  e97c 4a            	dec	a
1628  e97d 2616          	jrne	L537
1629  e97f               L147:
1631  e97f e61b          	ld	a,(27,x)
1632  e981 a105          	cp	a,#5
1633  e983 2610          	jrne	L537
1634  e985               L737:
1635                     ; 536             uip_connr->tcpstateflags = UIP_CLOSED;
1637  e985 6f19          	clr	(25,x)
1638                     ; 539             uip_flags = UIP_TIMEDOUT;
1640  e987 358002c8      	mov	_uip_flags,#128
1641                     ; 540             UIP_APPCALL(); // Timeout call. uip_len was cleared above.
1643  e98b cdf64c        	call	_uip_TcpAppHubCall
1645                     ; 543             BUF->flags = TCP_RST | TCP_ACK;
1647  e98e 351403a6      	mov	_uip_buf+47,#20
1648                     ; 544             goto tcp_send_nodata;
1650  e992 ccf051        	jra	L736
1651  e995               L537:
1652                     ; 548 	  if (uip_connr->nrtx > 4) uip_connr->nrtx = 4;
1654  e995 1e04          	ldw	x,(OFST-1,sp)
1655  e997 e61b          	ld	a,(27,x)
1656  e999 a105          	cp	a,#5
1657  e99b 2504          	jrult	L347
1660  e99d a604          	ld	a,#4
1661  e99f e71b          	ld	(27,x),a
1662  e9a1               L347:
1663                     ; 549 	  uip_connr->timer = (uint8_t)(UIP_RTO << uip_connr->nrtx);
1665  e9a1 5f            	clrw	x
1666  e9a2 97            	ld	xl,a
1667  e9a3 a603          	ld	a,#3
1668  e9a5 5d            	tnzw	x
1669  e9a6 2704          	jreq	L011
1670  e9a8               L211:
1671  e9a8 48            	sll	a
1672  e9a9 5a            	decw	x
1673  e9aa 26fc          	jrne	L211
1674  e9ac               L011:
1675  e9ac 1e04          	ldw	x,(OFST-1,sp)
1676  e9ae e71a          	ld	(26,x),a
1677                     ; 550 	  ++(uip_connr->nrtx);
1679  e9b0 6c1b          	inc	(27,x)
1680                     ; 559           switch (uip_connr->tcpstateflags & UIP_TS_MASK) {
1683  e9b2 e619          	ld	a,(25,x)
1684  e9b4 a40f          	and	a,#15
1686                     ; 580             case UIP_FIN_WAIT_1:
1686                     ; 581             case UIP_CLOSING:
1686                     ; 582             case UIP_LAST_ACK:
1686                     ; 583               // In all these states we should retransmit a FINACK.
1686                     ; 584               goto tcp_send_finack;
1687  e9b6 4a            	dec	a
1688  e9b7 2603cced0d    	jreq	L106
1689  e9bc 4a            	dec	a
1690  e9bd 2714          	jreq	L565
1691  e9bf 4a            	dec	a
1692  e9c0 2717          	jreq	L765
1693  e9c2 4a            	dec	a
1694  e9c3 2603ccf04d    	jreq	LC004
1695  e9c8 a002          	sub	a,#2
1696  e9ca 27f9          	jreq	LC004
1697  e9cc a002          	sub	a,#2
1698  e9ce 27f5          	jreq	LC004
1699  e9d0 ccf21a        	jra	L356
1700  e9d3               L565:
1701                     ; 565 	    case UIP_SYN_SENT:
1701                     ; 566 	      // In the SYN_SENT state, we retransmit the SYN.
1701                     ; 567 	      BUF->flags = 0;
1703  e9d3 c703a6        	ld	_uip_buf+47,a
1704                     ; 568 	      goto tcp_send_syn;
1706  e9d6 cced11        	jra	L306
1707  e9d9               L765:
1708                     ; 571             case UIP_ESTABLISHED:
1708                     ; 572               // In the ESTABLISHED state, we call upon the application to do
1708                     ; 573 	      // the actual retransmit after which we jump into the code for
1708                     ; 574 	      // sending out the packet (the apprexmit label).
1708                     ; 575               uip_flags = UIP_REXMIT;
1710  e9d9 350402c8      	mov	_uip_flags,#4
1711                     ; 576               UIP_APPCALL(); // Call to get old data for retransmit.  uip_len
1713  e9dd cdf64c        	call	_uip_TcpAppHubCall
1715                     ; 578               goto apprexmit;
1717  e9e0 ccf094        	jra	L126
1718                     ; 580             case UIP_FIN_WAIT_1:
1718                     ; 581             case UIP_CLOSING:
1718                     ; 582             case UIP_LAST_ACK:
1718                     ; 583               // In all these states we should retransmit a FINACK.
1718                     ; 584               goto tcp_send_finack;
1720  e9e3               L137:
1721                     ; 589       else if ((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_ESTABLISHED) {
1723  e9e3 e619          	ld	a,(25,x)
1724  e9e5 a40f          	and	a,#15
1725  e9e7 a103          	cp	a,#3
1726                     ; 592         uip_flags = UIP_POLL;
1728  e9e9               LC001:
1729  e9e9 26e5          	jrne	L356
1731  e9eb 350802c8      	mov	_uip_flags,#8
1732                     ; 593         UIP_APPCALL(); // Check for new data to transmit. uip_len was cleared
1735                     ; 595         goto appsend;
1736  e9ef               L716:
1741  e9ef cdf64c        	call	_uip_TcpAppHubCall
1742                     ; 1178         appsend:
1742                     ; 1179 
1742                     ; 1180         if (uip_flags & UIP_ABORT) {
1744  e9f2 720a02c803cc  	btjf	_uip_flags,#5,L3521
1745                     ; 1181           uip_slen = 0;
1747  e9fa 5f            	clrw	x
1748  e9fb cf02b4        	ldw	_uip_slen,x
1749                     ; 1182           uip_connr->tcpstateflags = UIP_CLOSED;
1751  e9fe 1e04          	ldw	x,(OFST-1,sp)
1752                     ; 1183           BUF->flags = TCP_RST | TCP_ACK;
1754  ea00 351403a6      	mov	_uip_buf+47,#20
1755  ea04 6f19          	clr	(25,x)
1756                     ; 1184           goto tcp_send_nodata;
1758  ea06 ccf051        	jra	L736
1759  ea09               L507:
1760                     ; 609   if (BUF->vhl != 0x45) { // IP version and header length.
1763  ea09 c60385        	ld	a,_uip_buf+14
1764  ea0c a145          	cp	a,#69
1765  ea0e 26c0          	jrne	L356
1766                     ; 612     goto drop;
1770                     ; 622   if ((BUF->len[0] << 8) + BUF->len[1] <= uip_len) {
1772  ea10 c60387        	ld	a,_uip_buf+16
1773  ea13 5f            	clrw	x
1774  ea14 97            	ld	xl,a
1775  ea15 4f            	clr	a
1776  ea16 cb0388        	add	a,_uip_buf+17
1777  ea19 2401          	jrnc	L021
1778  ea1b 5c            	incw	x
1779  ea1c               L021:
1780  ea1c 02            	rlwa	x,a
1781  ea1d c30373        	cpw	x,_uip_len
1782  ea20 22ae          	jrugt	L356
1783                     ; 623     uip_len = (BUF->len[0] << 8) + BUF->len[1];
1785  ea22 c60387        	ld	a,_uip_buf+16
1786  ea25 5f            	clrw	x
1787  ea26 97            	ld	xl,a
1788  ea27 4f            	clr	a
1789  ea28 cb0388        	add	a,_uip_buf+17
1790  ea2b 2401          	jrnc	L221
1791  ea2d 5c            	incw	x
1792  ea2e               L221:
1793  ea2e c70374        	ld	_uip_len+1,a
1794  ea31 9f            	ld	a,xl
1795  ea32 c70373        	ld	_uip_len,a
1797                     ; 628   if ((BUF->ipoffset[0] & 0x3f) != 0 || BUF->ipoffset[1] != 0) {
1799  ea35 c6038b        	ld	a,_uip_buf+20
1800  ea38 a53f          	bcp	a,#63
1801  ea3a 2694          	jrne	L356
1803  ea3c c6038c        	ld	a,_uip_buf+21
1804  ea3f 268f          	jrne	L356
1805                     ; 635   if (!uip_ipaddr_cmp(BUF->destipaddr, uip_hostaddr)) {
1807  ea41 ce0395        	ldw	x,_uip_buf+30
1808  ea44 c302c4        	cpw	x,_uip_hostaddr
1809  ea47 2687          	jrne	L356
1811  ea49 ce0397        	ldw	x,_uip_buf+32
1812  ea4c c302c6        	cpw	x,_uip_hostaddr+2
1813  ea4f 2703ccf21a    	jrne	L356
1814                     ; 640   if (uip_ipchksum() != 0xffff) { /* Compute and check the IP header checksum. */
1816  ea54 cde77c        	call	_uip_ipchksum
1818  ea57 5c            	incw	x
1819  ea58 26f7          	jrne	L356
1820                     ; 643     goto drop;
1824                     ; 646   if (BUF->proto == UIP_PROTO_TCP) {
1826  ea5a c6038e        	ld	a,_uip_buf+23
1827  ea5d a106          	cp	a,#6
1828  ea5f 2609          	jrne	L577
1829                     ; 649     goto tcp_input;
1830                     ; 697   if (uip_tcpchksum() != 0xffff) { /* Compute and check the TCP checksum. */
1833  ea61 cde7e2        	call	_uip_tcpchksum
1835  ea64 5c            	incw	x
1836  ea65 273f          	jreq	L7101
1837                     ; 700     goto drop;
1841  ea67 ccf21a        	jra	L356
1842  ea6a               L577:
1843                     ; 654   if (BUF->proto != UIP_PROTO_ICMP) { // We only allow ICMP packets from here.
1845  ea6a 4a            	dec	a
1846  ea6b 26fa          	jrne	L356
1847                     ; 657     goto drop;
1851                     ; 665   if (ICMPBUF->type != ICMP_ECHO) {
1854  ea6d c60399        	ld	a,_uip_buf+34
1855  ea70 a108          	cp	a,#8
1856  ea72 26f3          	jrne	L356
1857                     ; 668     goto drop;
1861                     ; 671   ICMPBUF->type = ICMP_ECHO_REPLY;
1863  ea74 725f0399      	clr	_uip_buf+34
1864                     ; 673   if (ICMPBUF->icmpchksum >= HTONS(0xffff - (ICMP_ECHO << 8))) {
1866  ea78 ce039b        	ldw	x,_uip_buf+36
1867  ea7b a3f7ff        	cpw	x,#63487
1868  ea7e 2505          	jrult	L3001
1869                     ; 674     ICMPBUF->icmpchksum += HTONS(ICMP_ECHO << 8) + 1;
1871  ea80 1c0801        	addw	x,#2049
1873  ea83 2003          	jra	L7001
1874  ea85               L3001:
1875                     ; 677     ICMPBUF->icmpchksum += HTONS(ICMP_ECHO << 8);
1877  ea85 1c0800        	addw	x,#2048
1878  ea88               L7001:
1879  ea88 cf039b        	ldw	_uip_buf+36,x
1880                     ; 681   uip_ipaddr_copy(BUF->destipaddr, BUF->srcipaddr);
1882  ea8b ce0391        	ldw	x,_uip_buf+26
1883  ea8e cf0395        	ldw	_uip_buf+30,x
1886  ea91 ce0393        	ldw	x,_uip_buf+28
1887  ea94 cf0397        	ldw	_uip_buf+32,x
1888                     ; 682   uip_ipaddr_copy(BUF->srcipaddr, uip_hostaddr);
1890  ea97 ce02c4        	ldw	x,_uip_hostaddr
1891  ea9a cf0391        	ldw	_uip_buf+26,x
1894  ea9d ce02c6        	ldw	x,_uip_hostaddr+2
1895  eaa0 cf0393        	ldw	_uip_buf+28,x
1896                     ; 685   goto send;
1897                     ; 1424   uip_flags = 0;
1899                     ; 1426   return;
1901  eaa3 ccf21e        	jra	L222
1902  eaa6               L7101:
1903                     ; 705   for (uip_connr = &uip_conns[0]; uip_connr <= &uip_conns[UIP_CONNS - 1]; ++uip_connr) {
1905  eaa6 ae02cd        	ldw	x,#_uip_conns
1907  eaa9 204d          	jra	L5201
1908  eaab               L1201:
1909                     ; 706     if (uip_connr->tcpstateflags != UIP_CLOSED
1909                     ; 707       && BUF->destport == uip_connr->lport
1909                     ; 708       && BUF->srcport == uip_connr->rport
1909                     ; 709       && uip_ipaddr_cmp(BUF->srcipaddr, uip_connr->ripaddr)) {
1911  eaab e619          	ld	a,(25,x)
1912  eaad 2746          	jreq	L1301
1914  eaaf 9093          	ldw	y,x
1915  eab1 90ee04        	ldw	y,(4,y)
1916  eab4 90c3039b      	cpw	y,_uip_buf+36
1917  eab8 263b          	jrne	L1301
1919  eaba 9093          	ldw	y,x
1920  eabc 90ee06        	ldw	y,(6,y)
1921  eabf 90c30399      	cpw	y,_uip_buf+34
1922  eac3 2630          	jrne	L1301
1924  eac5 9093          	ldw	y,x
1925  eac7 90fe          	ldw	y,(y)
1926  eac9 90c30391      	cpw	y,_uip_buf+26
1927  eacd 2626          	jrne	L1301
1929  eacf 9093          	ldw	y,x
1930  ead1 90ee02        	ldw	y,(2,y)
1931  ead4 90c30393      	cpw	y,_uip_buf+28
1932  ead8 261b          	jrne	L1301
1933                     ; 710       goto found;
1934                     ; 903   found:
1934                     ; 904 
1934                     ; 905   // found will be jumped to if we found an active connection.
1934                     ; 906   uip_conn = uip_connr;
1936  eada cf0371        	ldw	_uip_conn,x
1937                     ; 907   uip_flags = 0;
1939  eadd 725f02c8      	clr	_uip_flags
1940                     ; 911   if (BUF->flags & TCP_RST) {
1942  eae1 720403a603cc  	btjf	_uip_buf+47,#2,L1411
1943                     ; 912     uip_connr->tcpstateflags = UIP_CLOSED;
1945  eae9 6f19          	clr	(25,x)
1946                     ; 913     uip_flags = UIP_ABORT;
1948  eaeb 352002c8      	mov	_uip_flags,#32
1949                     ; 919     UIP_APPCALL(); // ????
1951  eaef cdf64c        	call	_uip_TcpAppHubCall
1953                     ; 920     goto drop;
1955  eaf2 ccf21a        	jra	L356
1956  eaf5               L1301:
1957                     ; 705   for (uip_connr = &uip_conns[0]; uip_connr <= &uip_conns[UIP_CONNS - 1]; ++uip_connr) {
1959  eaf5 1c0029        	addw	x,#41
1960  eaf8               L5201:
1961  eaf8 1f04          	ldw	(OFST-1,sp),x
1965  eafa a30348        	cpw	x,#_uip_conns+123
1966  eafd 23ac          	jrule	L1201
1967                     ; 718   if ((BUF->flags & TCP_CTL) != TCP_SYN) {
1969  eaff c603a6        	ld	a,_uip_buf+47
1970  eb02 a43f          	and	a,#63
1971  eb04 a102          	cp	a,#2
1972  eb06 2703ccef7c    	jrne	L575
1973                     ; 719     goto reset;
1975                     ; 722   tmp16 = BUF->destport;
1977  eb0b ce039b        	ldw	x,_uip_buf+36
1978  eb0e cf02a2        	ldw	L34_tmp16,x
1979                     ; 724   for (c = 0; c < UIP_LISTENPORTS; ++c) {
1981  eb11 4f            	clr	a
1982  eb12 c702a5        	ld	L73_c,a
1983  eb15               L5301:
1984                     ; 725     if (tmp16 == uip_listenports[c]) goto found_listen;
1986  eb15 5f            	clrw	x
1987  eb16 97            	ld	xl,a
1988  eb17 58            	sllw	x
1989  eb18 9093          	ldw	y,x
1990  eb1a 90de02ac      	ldw	y,(_uip_listenports,y)
1991  eb1e 90c302a2      	cpw	y,L34_tmp16
1992  eb22 261b          	jrne	L3401
1994                     ; 787   found_listen:
1994                     ; 788   // found_listen will be jumped to if we matched the incoming packet with a
1994                     ; 789   // connection in LISTEN. In that case we should create a new connection and
1994                     ; 790   // send a SYNACK in return.
1994                     ; 791   // First we check if there are any connections avaliable. Unused connections
1994                     ; 792   // are kept in the same table as used connections, but unused ones have the
1994                     ; 793   // tcpstate set to CLOSED. Also, connections in TIME_WAIT are kept track of
1994                     ; 794   // and we'll use the oldest one if no CLOSED connections are found. Thanks
1994                     ; 795   // to Eddie C. Dost for a very nice algorithm for the TIME_WAIT search.
1994                     ; 796   uip_connr = 0;
1996  eb24 5f            	clrw	x
1997  eb25 1f04          	ldw	(OFST-1,sp),x
1999                     ; 797   for (c = 0; c < UIP_CONNS; ++c) {
2001  eb27 4f            	clr	a
2002  eb28 c702a5        	ld	L73_c,a
2003  eb2b               L5601:
2004                     ; 798     if (uip_conns[c].tcpstateflags == UIP_CLOSED) {
2006  eb2b 97            	ld	xl,a
2007  eb2c a629          	ld	a,#41
2008  eb2e 42            	mul	x,a
2009  eb2f d602e6        	ld	a,(_uip_conns+25,x)
2010  eb32 2703ccebda    	jrne	L3701
2011                     ; 799       uip_connr = &uip_conns[c];
2013  eb37 1c02cd        	addw	x,#_uip_conns
2014  eb3a 1f04          	ldw	(OFST-1,sp),x
2016                     ; 800       break;
2018  eb3c ccec0c        	jra	L1701
2019  eb3f               L3401:
2020                     ; 724   for (c = 0; c < UIP_LISTENPORTS; ++c) {
2022  eb3f 725c02a5      	inc	L73_c
2025  eb43 c602a5        	ld	a,L73_c
2026  eb46 a104          	cp	a,#4
2027  eb48 25cb          	jrult	L5301
2029  eb4a ccef7c        	jra	L575
2030  eb4d               L5401:
2031                     ; 740   BUF->flags = TCP_RST | TCP_ACK;
2034  eb4d 351403a6      	mov	_uip_buf+47,#20
2035                     ; 741   uip_len = UIP_IPTCPH_LEN;
2037  eb51 ae0028        	ldw	x,#40
2038  eb54 cf0373        	ldw	_uip_len,x
2039                     ; 742   BUF->tcpoffset = 5 << 4;
2041  eb57 355003a5      	mov	_uip_buf+46,#80
2042                     ; 745   c = BUF->seqno[3];
2044  eb5b 5503a002a5    	mov	L73_c,_uip_buf+41
2045                     ; 746   BUF->seqno[3] = BUF->ackno[3];
2047  eb60 5503a403a0    	mov	_uip_buf+41,_uip_buf+45
2048                     ; 747   BUF->ackno[3] = c;
2050  eb65 5502a503a4    	mov	_uip_buf+45,L73_c
2051                     ; 749   c = BUF->seqno[2];
2053  eb6a 55039f02a5    	mov	L73_c,_uip_buf+40
2054                     ; 750   BUF->seqno[2] = BUF->ackno[2];
2056  eb6f 5503a3039f    	mov	_uip_buf+40,_uip_buf+44
2057                     ; 751   BUF->ackno[2] = c;
2059  eb74 5502a503a3    	mov	_uip_buf+44,L73_c
2060                     ; 753   c = BUF->seqno[1];
2062  eb79 55039e02a5    	mov	L73_c,_uip_buf+39
2063                     ; 754   BUF->seqno[1] = BUF->ackno[1];
2065  eb7e 5503a2039e    	mov	_uip_buf+39,_uip_buf+43
2066                     ; 755   BUF->ackno[1] = c;
2068  eb83 5502a503a2    	mov	_uip_buf+43,L73_c
2069                     ; 757   c = BUF->seqno[0];
2071  eb88 55039d02a5    	mov	L73_c,_uip_buf+38
2072                     ; 758   BUF->seqno[0] = BUF->ackno[0];
2074  eb8d 5503a1039d    	mov	_uip_buf+38,_uip_buf+42
2075                     ; 759   BUF->ackno[0] = c;
2077  eb92 5502a503a1    	mov	_uip_buf+42,L73_c
2078                     ; 764   if (++BUF->ackno[3] == 0) {
2080  eb97 725c03a4      	inc	_uip_buf+45
2081  eb9b 2610          	jrne	L7401
2082                     ; 765     if (++BUF->ackno[2] == 0) {
2084  eb9d 725c03a3      	inc	_uip_buf+44
2085  eba1 260a          	jrne	L7401
2086                     ; 766       if (++BUF->ackno[1] == 0) {
2088  eba3 725c03a2      	inc	_uip_buf+43
2089  eba7 2604          	jrne	L7401
2090                     ; 767         ++BUF->ackno[0];
2092  eba9 725c03a1      	inc	_uip_buf+42
2093  ebad               L7401:
2094                     ; 773   tmp16 = BUF->srcport;
2096  ebad ce0399        	ldw	x,_uip_buf+34
2097  ebb0 cf02a2        	ldw	L34_tmp16,x
2098                     ; 774   BUF->srcport = BUF->destport;
2100  ebb3 ce039b        	ldw	x,_uip_buf+36
2101  ebb6 cf0399        	ldw	_uip_buf+34,x
2102                     ; 775   BUF->destport = tmp16;
2104  ebb9 ce02a2        	ldw	x,L34_tmp16
2105  ebbc cf039b        	ldw	_uip_buf+36,x
2106                     ; 778   uip_ipaddr_copy(BUF->destipaddr, BUF->srcipaddr);
2108  ebbf ce0391        	ldw	x,_uip_buf+26
2109  ebc2 cf0395        	ldw	_uip_buf+30,x
2112  ebc5 ce0393        	ldw	x,_uip_buf+28
2113  ebc8 cf0397        	ldw	_uip_buf+32,x
2114                     ; 779   uip_ipaddr_copy(BUF->srcipaddr, uip_hostaddr);
2116  ebcb ce02c4        	ldw	x,_uip_hostaddr
2117  ebce cf0391        	ldw	_uip_buf+26,x
2120  ebd1 ce02c6        	ldw	x,_uip_hostaddr+2
2121  ebd4 cf0393        	ldw	_uip_buf+28,x
2122                     ; 782   goto tcp_send_noconn;
2124  ebd7 ccf1cb        	jra	L546
2125  ebda               L3701:
2126                     ; 802     if (uip_conns[c].tcpstateflags == UIP_TIME_WAIT) {
2128  ebda a107          	cp	a,#7
2129  ebdc 2620          	jrne	L5701
2130                     ; 803       if (uip_connr == 0 || uip_conns[c].timer > uip_connr->timer) {
2132  ebde 1e04          	ldw	x,(OFST-1,sp)
2133  ebe0 2710          	jreq	L1011
2135  ebe2 c602a5        	ld	a,L73_c
2136  ebe5 97            	ld	xl,a
2137  ebe6 a629          	ld	a,#41
2138  ebe8 42            	mul	x,a
2139  ebe9 d602e7        	ld	a,(_uip_conns+26,x)
2140  ebec 1e04          	ldw	x,(OFST-1,sp)
2141  ebee e11a          	cp	a,(26,x)
2142  ebf0 230c          	jrule	L5701
2143  ebf2               L1011:
2144                     ; 804         uip_connr = &uip_conns[c];
2146  ebf2 c602a5        	ld	a,L73_c
2147  ebf5 97            	ld	xl,a
2148  ebf6 a629          	ld	a,#41
2149  ebf8 42            	mul	x,a
2150  ebf9 1c02cd        	addw	x,#_uip_conns
2151  ebfc 1f04          	ldw	(OFST-1,sp),x
2153  ebfe               L5701:
2154                     ; 797   for (c = 0; c < UIP_CONNS; ++c) {
2156  ebfe 725c02a5      	inc	L73_c
2159  ec02 c602a5        	ld	a,L73_c
2160  ec05 a104          	cp	a,#4
2161  ec07 2403cceb2b    	jrult	L5601
2162  ec0c               L1701:
2163                     ; 809   if (uip_connr == 0) {
2165  ec0c 1e04          	ldw	x,(OFST-1,sp)
2166  ec0e 2603ccf21a    	jreq	L356
2167                     ; 814     goto drop;
2170                     ; 816   uip_conn = uip_connr;
2172  ec13 cf0371        	ldw	_uip_conn,x
2173                     ; 819   uip_connr->rto = uip_connr->timer = UIP_RTO;
2175  ec16 a603          	ld	a,#3
2176  ec18 e71a          	ld	(26,x),a
2177  ec1a e718          	ld	(24,x),a
2178                     ; 820   uip_connr->sa = 0;
2180  ec1c 6f16          	clr	(22,x)
2181                     ; 821   uip_connr->sv = 4;
2183  ec1e 4c            	inc	a
2184  ec1f e717          	ld	(23,x),a
2185                     ; 822   uip_connr->nrtx = 0;
2187  ec21 6f1b          	clr	(27,x)
2188                     ; 823   uip_connr->lport = BUF->destport;
2190  ec23 90ce039b      	ldw	y,_uip_buf+36
2191  ec27 ef04          	ldw	(4,x),y
2192                     ; 824   uip_connr->rport = BUF->srcport;
2194  ec29 90ce0399      	ldw	y,_uip_buf+34
2195  ec2d ef06          	ldw	(6,x),y
2196                     ; 825   uip_ipaddr_copy(uip_connr->ripaddr, BUF->srcipaddr);
2198  ec2f 90ce0391      	ldw	y,_uip_buf+26
2199  ec33 ff            	ldw	(x),y
2202  ec34 90ce0393      	ldw	y,_uip_buf+28
2203  ec38 ef02          	ldw	(2,x),y
2204                     ; 826   uip_connr->tcpstateflags = UIP_SYN_RCVD;
2206  ec3a a601          	ld	a,#1
2207  ec3c e719          	ld	(25,x),a
2208                     ; 828   uip_connr->snd_nxt[0] = iss[0];
2210  ec3e c602a6        	ld	a,L53_iss
2211  ec41 e70c          	ld	(12,x),a
2212                     ; 829   uip_connr->snd_nxt[1] = iss[1];
2214  ec43 c602a7        	ld	a,L53_iss+1
2215  ec46 e70d          	ld	(13,x),a
2216                     ; 830   uip_connr->snd_nxt[2] = iss[2];
2218  ec48 c602a8        	ld	a,L53_iss+2
2219  ec4b e70e          	ld	(14,x),a
2220                     ; 831   uip_connr->snd_nxt[3] = iss[3];
2222  ec4d c602a9        	ld	a,L53_iss+3
2223  ec50 e70f          	ld	(15,x),a
2224                     ; 832   uip_connr->len = 1;
2226  ec52 90ae0001      	ldw	y,#1
2227  ec56 ef10          	ldw	(16,x),y
2228                     ; 835   uip_connr->rcv_nxt[3] = BUF->seqno[3];
2230  ec58 c603a0        	ld	a,_uip_buf+41
2231  ec5b e70b          	ld	(11,x),a
2232                     ; 836   uip_connr->rcv_nxt[2] = BUF->seqno[2];
2234  ec5d c6039f        	ld	a,_uip_buf+40
2235  ec60 e70a          	ld	(10,x),a
2236                     ; 837   uip_connr->rcv_nxt[1] = BUF->seqno[1];
2238  ec62 c6039e        	ld	a,_uip_buf+39
2239  ec65 e709          	ld	(9,x),a
2240                     ; 838   uip_connr->rcv_nxt[0] = BUF->seqno[0];
2242  ec67 c6039d        	ld	a,_uip_buf+38
2243  ec6a e708          	ld	(8,x),a
2244                     ; 839   uip_add_rcv_nxt(1);
2246  ec6c ae0001        	ldw	x,#1
2247  ec6f cde8d4        	call	L545_uip_add_rcv_nxt
2249                     ; 842   if ((BUF->tcpoffset & 0xf0) > 0x50) {
2251  ec72 c603a5        	ld	a,_uip_buf+46
2252  ec75 a4f0          	and	a,#240
2253  ec77 a151          	cp	a,#81
2254  ec79 2403cced0d    	jrult	L106
2255                     ; 843     for (c = 0; c < ((BUF->tcpoffset >> 4) - 5) << 2;) {
2257  ec7e 725f02a5      	clr	L73_c
2259  ec82 206b          	jra	L7111
2260  ec84               L3111:
2261                     ; 844       opt = uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + c];
2263  ec84 5f            	clrw	x
2264  ec85 97            	ld	xl,a
2265  ec86 d603ad        	ld	a,(_uip_buf+54,x)
2266  ec89 c702a4        	ld	L14_opt,a
2267                     ; 845       if (opt == TCP_OPT_END) {
2269  ec8c 277f          	jreq	L106
2270                     ; 847         break;
2272                     ; 849       else if (opt == TCP_OPT_NOOP) {
2274  ec8e a101          	cp	a,#1
2275  ec90 2606          	jrne	L7211
2276                     ; 850         ++c;
2278  ec92 725c02a5      	inc	L73_c
2280  ec96 2057          	jra	L7111
2281  ec98               L7211:
2282                     ; 853       else if (opt == TCP_OPT_MSS
2282                     ; 854         && uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == TCP_OPT_MSS_LEN) {
2284  ec98 a102          	cp	a,#2
2285  ec9a 2640          	jrne	L3311
2287  ec9c c602a5        	ld	a,L73_c
2288  ec9f 5f            	clrw	x
2289  eca0 97            	ld	xl,a
2290  eca1 d603ae        	ld	a,(_uip_buf+55,x)
2291  eca4 a104          	cp	a,#4
2292  eca6 2634          	jrne	L3311
2293                     ; 856         tmp16 = ((uint16_t)uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 2 + c] << 8)
2293                     ; 857 	        | (uint16_t)uip_buf[UIP_IPTCPH_LEN + UIP_LLH_LEN + 3 + c];
2295  eca8 c602a5        	ld	a,L73_c
2296  ecab 5f            	clrw	x
2297  ecac 97            	ld	xl,a
2298  ecad d603b0        	ld	a,(_uip_buf+57,x)
2299  ecb0 5f            	clrw	x
2300  ecb1 97            	ld	xl,a
2301  ecb2 1f01          	ldw	(OFST-4,sp),x
2303  ecb4 5f            	clrw	x
2304  ecb5 c602a5        	ld	a,L73_c
2305  ecb8 97            	ld	xl,a
2306  ecb9 d603af        	ld	a,(_uip_buf+56,x)
2307  ecbc 5f            	clrw	x
2308  ecbd 97            	ld	xl,a
2309  ecbe 7b02          	ld	a,(OFST-3,sp)
2310  ecc0 01            	rrwa	x,a
2311  ecc1 1a01          	or	a,(OFST-4,sp)
2312  ecc3 01            	rrwa	x,a
2313  ecc4 cf02a2        	ldw	L34_tmp16,x
2314                     ; 858         uip_connr->initialmss = uip_connr->mss = tmp16 > UIP_TCP_MSS ? UIP_TCP_MSS : tmp16;
2316  ecc7 a301b9        	cpw	x,#441
2317  ecca 2503          	jrult	L231
2318  eccc ae01b8        	ldw	x,#440
2319  eccf               L231:
2320  eccf 1604          	ldw	y,(OFST-1,sp)
2321  ecd1 90ef12        	ldw	(18,y),x
2322  ecd4 93            	ldw	x,y
2323  ecd5 90ee12        	ldw	y,(18,y)
2324  ecd8 ef14          	ldw	(20,x),y
2325                     ; 861         break;
2327  ecda 2031          	jra	L106
2328  ecdc               L3311:
2329                     ; 866         if (uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == 0) {
2331  ecdc c602a5        	ld	a,L73_c
2332  ecdf 5f            	clrw	x
2333  ece0 97            	ld	xl,a
2334  ece1 724d03ae      	tnz	(_uip_buf+55,x)
2335  ece5 2726          	jreq	L106
2336                     ; 869           break;
2338                     ; 871         c += uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c];
2340  ece7 5f            	clrw	x
2341  ece8 97            	ld	xl,a
2342  ece9 db03ae        	add	a,(_uip_buf+55,x)
2343  ecec c702a5        	ld	L73_c,a
2344  ecef               L7111:
2345                     ; 843     for (c = 0; c < ((BUF->tcpoffset >> 4) - 5) << 2;) {
2347  ecef c603a5        	ld	a,_uip_buf+46
2348  ecf2 4e            	swap	a
2349  ecf3 a40f          	and	a,#15
2350  ecf5 5f            	clrw	x
2351  ecf6 97            	ld	xl,a
2352  ecf7 58            	sllw	x
2353  ecf8 58            	sllw	x
2354  ecf9 1d0014        	subw	x,#20
2355  ecfc c602a5        	ld	a,L73_c
2356  ecff 905f          	clrw	y
2357  ed01 9097          	ld	yl,a
2358  ed03 90bf07        	ldw	c_y,y
2359  ed06 b307          	cpw	x,c_y
2360  ed08 2d03ccec84    	jrsgt	L3111
2361  ed0d               L106:
2362                     ; 879   tcp_send_synack:
2362                     ; 880   BUF->flags = TCP_ACK;
2364  ed0d 351003a6      	mov	_uip_buf+47,#16
2365  ed11               L306:
2366                     ; 882   tcp_send_syn:
2366                     ; 883   BUF->flags |= TCP_SYN;
2368  ed11 721203a6      	bset	_uip_buf+47,#1
2369                     ; 892   BUF->optdata[0] = TCP_OPT_MSS;
2371  ed15 350203ad      	mov	_uip_buf+54,#2
2372                     ; 893   BUF->optdata[1] = TCP_OPT_MSS_LEN;
2374  ed19 350403ae      	mov	_uip_buf+55,#4
2375                     ; 894   BUF->optdata[2] = (UIP_TCP_MSS) / 256;
2377  ed1d 350103af      	mov	_uip_buf+56,#1
2378                     ; 895   BUF->optdata[3] = (UIP_TCP_MSS) & 255;
2380  ed21 35b803b0      	mov	_uip_buf+57,#184
2381                     ; 896   uip_len = UIP_IPTCPH_LEN + TCP_OPT_MSS_LEN;
2383  ed25 ae002c        	ldw	x,#44
2384  ed28 cf0373        	ldw	_uip_len,x
2385                     ; 897   BUF->tcpoffset = ((UIP_TCPH_LEN + TCP_OPT_MSS_LEN) / 4) << 4;
2387  ed2b 356003a5      	mov	_uip_buf+46,#96
2388                     ; 898   goto tcp_send;
2390  ed2f ccf0cb        	jra	L346
2391  ed32               L1411:
2392                     ; 934   c = (uint8_t)((BUF->tcpoffset >> 4) << 2);
2394  ed32 c603a5        	ld	a,_uip_buf+46
2395  ed35 4e            	swap	a
2396  ed36 a40f          	and	a,#15
2397  ed38 48            	sll	a
2398  ed39 48            	sll	a
2399  ed3a c702a5        	ld	L73_c,a
2400                     ; 938   uip_len = uip_len - c - UIP_IPH_LEN;
2402  ed3d c60373        	ld	a,_uip_len
2403  ed40 97            	ld	xl,a
2404  ed41 c60374        	ld	a,_uip_len+1
2405  ed44 c002a5        	sub	a,L73_c
2406  ed47 2401          	jrnc	L041
2407  ed49 5a            	decw	x
2408  ed4a               L041:
2409  ed4a 02            	rlwa	x,a
2410  ed4b 1d0014        	subw	x,#20
2411  ed4e cf0373        	ldw	_uip_len,x
2412                     ; 942   if (!(((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_SYN_SENT)
2412                     ; 943     && ((BUF->flags & TCP_CTL) == (TCP_SYN | TCP_ACK)))) {
2414  ed51 1e04          	ldw	x,(OFST-1,sp)
2415  ed53 e619          	ld	a,(25,x)
2416  ed55 a40f          	and	a,#15
2417  ed57 a102          	cp	a,#2
2418  ed59 2609          	jrne	L5411
2420  ed5b c603a6        	ld	a,_uip_buf+47
2421  ed5e a43f          	and	a,#63
2422  ed60 a112          	cp	a,#18
2423  ed62 272d          	jreq	L3411
2424  ed64               L5411:
2425                     ; 945     if ((uip_len > 0 || ((BUF->flags & (TCP_SYN | TCP_FIN)) != 0))
2425                     ; 946       && (BUF->seqno[0] != uip_connr->rcv_nxt[0]
2425                     ; 947       || BUF->seqno[1] != uip_connr->rcv_nxt[1]
2425                     ; 948       || BUF->seqno[2] != uip_connr->rcv_nxt[2]
2425                     ; 949       || BUF->seqno[3] != uip_connr->rcv_nxt[3])) {
2427  ed64 ce0373        	ldw	x,_uip_len
2428  ed67 2607          	jrne	L1511
2430  ed69 c603a6        	ld	a,_uip_buf+47
2431  ed6c a503          	bcp	a,#3
2432  ed6e 2721          	jreq	L3411
2433  ed70               L1511:
2435  ed70 1e04          	ldw	x,(OFST-1,sp)
2436  ed72 e608          	ld	a,(8,x)
2437  ed74 c1039d        	cp	a,_uip_buf+38
2438  ed77 2703ccf1bc    	jrne	L536
2440  ed7c e609          	ld	a,(9,x)
2441  ed7e c1039e        	cp	a,_uip_buf+39
2442  ed81 26f6          	jrne	L536
2444  ed83 e60a          	ld	a,(10,x)
2445  ed85 c1039f        	cp	a,_uip_buf+40
2446  ed88 26ef          	jrne	L536
2448  ed8a e60b          	ld	a,(11,x)
2449  ed8c c103a0        	cp	a,_uip_buf+41
2450  ed8f 26e8          	jrne	L536
2451  ed91               L3411:
2452                     ; 957   if ((BUF->flags & TCP_ACK) && uip_outstanding(uip_connr)) {
2454  ed91 720803a603cc  	btjf	_uip_buf+47,#4,L1611
2456  ed99 1e04          	ldw	x,(OFST-1,sp)
2457  ed9b e611          	ld	a,(17,x)
2458  ed9d ea10          	or	a,(16,x)
2459  ed9f 27f5          	jreq	L1611
2460                     ; 958     uip_add32(uip_connr->snd_nxt, uip_connr->len);
2462  eda1 ee10          	ldw	x,(16,x)
2463  eda3 89            	pushw	x
2464  eda4 1e06          	ldw	x,(OFST+1,sp)
2465  eda6 1c000c        	addw	x,#12
2466  eda9 cde6d7        	call	_uip_add32
2468  edac c603a1        	ld	a,_uip_buf+42
2469  edaf c102c9        	cp	a,_uip_acc32
2470  edb2 85            	popw	x
2471                     ; 959     if (BUF->ackno[0] == uip_acc32[0]
2471                     ; 960       && BUF->ackno[1] == uip_acc32[1]
2471                     ; 961       && BUF->ackno[2] == uip_acc32[2]
2471                     ; 962       && BUF->ackno[3] == uip_acc32[3]) {
2473  edb3 26e1          	jrne	L1611
2475  edb5 c603a2        	ld	a,_uip_buf+43
2476  edb8 c102ca        	cp	a,_uip_acc32+1
2477  edbb 26d9          	jrne	L1611
2479  edbd c603a3        	ld	a,_uip_buf+44
2480  edc0 c102cb        	cp	a,_uip_acc32+2
2481  edc3 26d1          	jrne	L1611
2483  edc5 c603a4        	ld	a,_uip_buf+45
2484  edc8 c102cc        	cp	a,_uip_acc32+3
2485  edcb 2679          	jrne	L1611
2486                     ; 964       uip_connr->snd_nxt[0] = uip_acc32[0];
2488  edcd 1e04          	ldw	x,(OFST-1,sp)
2489  edcf c602c9        	ld	a,_uip_acc32
2490  edd2 e70c          	ld	(12,x),a
2491                     ; 965       uip_connr->snd_nxt[1] = uip_acc32[1];
2493  edd4 c602ca        	ld	a,_uip_acc32+1
2494  edd7 e70d          	ld	(13,x),a
2495                     ; 966       uip_connr->snd_nxt[2] = uip_acc32[2];
2497  edd9 c602cb        	ld	a,_uip_acc32+2
2498  eddc e70e          	ld	(14,x),a
2499                     ; 967       uip_connr->snd_nxt[3] = uip_acc32[3];
2501  edde c602cc        	ld	a,_uip_acc32+3
2502  ede1 e70f          	ld	(15,x),a
2503                     ; 970       if (uip_connr->nrtx == 0) {
2505  ede3 e61b          	ld	a,(27,x)
2506  ede5 2653          	jrne	L5611
2507                     ; 972         m = (int8_t)(uip_connr->rto - uip_connr->timer);
2509  ede7 e61a          	ld	a,(26,x)
2510  ede9 e018          	sub	a,(24,x)
2511  edeb 40            	neg	a
2512  edec 6b03          	ld	(OFST-2,sp),a
2514                     ; 974         m = (int8_t)(m - (uip_connr->sa >> 3));
2516  edee e616          	ld	a,(22,x)
2517  edf0 44            	srl	a
2518  edf1 44            	srl	a
2519  edf2 44            	srl	a
2520  edf3 5f            	clrw	x
2521  edf4 97            	ld	xl,a
2522  edf5 1f01          	ldw	(OFST-4,sp),x
2524  edf7 5f            	clrw	x
2525  edf8 7b03          	ld	a,(OFST-2,sp)
2526  edfa 4d            	tnz	a
2527  edfb 2a01          	jrpl	L441
2528  edfd 53            	cplw	x
2529  edfe               L441:
2530  edfe 97            	ld	xl,a
2531  edff 72f001        	subw	x,(OFST-4,sp)
2532  ee02 01            	rrwa	x,a
2533  ee03 6b03          	ld	(OFST-2,sp),a
2535                     ; 975         uip_connr->sa += m;
2537  ee05 1e04          	ldw	x,(OFST-1,sp)
2538  ee07 e616          	ld	a,(22,x)
2539  ee09 1b03          	add	a,(OFST-2,sp)
2540  ee0b e716          	ld	(22,x),a
2541                     ; 976         if (m < 0) m = (int8_t)(-m);
2543  ee0d 7b03          	ld	a,(OFST-2,sp)
2544  ee0f 2a02          	jrpl	L7611
2547  ee11 0003          	neg	(OFST-2,sp)
2549  ee13               L7611:
2550                     ; 977         m = (int8_t)(m - (uip_connr->sv >> 2));
2552  ee13 e617          	ld	a,(23,x)
2553  ee15 44            	srl	a
2554  ee16 44            	srl	a
2555  ee17 5f            	clrw	x
2556  ee18 97            	ld	xl,a
2557  ee19 1f01          	ldw	(OFST-4,sp),x
2559  ee1b 5f            	clrw	x
2560  ee1c 7b03          	ld	a,(OFST-2,sp)
2561  ee1e 4d            	tnz	a
2562  ee1f 2a01          	jrpl	L641
2563  ee21 53            	cplw	x
2564  ee22               L641:
2565  ee22 97            	ld	xl,a
2566  ee23 72f001        	subw	x,(OFST-4,sp)
2567  ee26 01            	rrwa	x,a
2568  ee27 6b03          	ld	(OFST-2,sp),a
2570                     ; 978         uip_connr->sv += m;
2572  ee29 1e04          	ldw	x,(OFST-1,sp)
2573  ee2b e617          	ld	a,(23,x)
2574  ee2d 1b03          	add	a,(OFST-2,sp)
2575  ee2f e717          	ld	(23,x),a
2576                     ; 979         uip_connr->rto = (uint8_t)((uip_connr->sa >> 3) + uip_connr->sv);
2578  ee31 e616          	ld	a,(22,x)
2579  ee33 44            	srl	a
2580  ee34 44            	srl	a
2581  ee35 44            	srl	a
2582  ee36 eb17          	add	a,(23,x)
2583  ee38 e718          	ld	(24,x),a
2584  ee3a               L5611:
2585                     ; 982       uip_flags = UIP_ACKDATA;
2587  ee3a 350102c8      	mov	_uip_flags,#1
2588                     ; 984       uip_connr->timer = uip_connr->rto;
2590  ee3e e618          	ld	a,(24,x)
2591  ee40 e71a          	ld	(26,x),a
2592                     ; 987       uip_connr->len = 0;
2594  ee42 905f          	clrw	y
2595  ee44 ef10          	ldw	(16,x),y
2596  ee46               L1611:
2597                     ; 992   switch (uip_connr->tcpstateflags & UIP_TS_MASK) {
2599  ee46 1e04          	ldw	x,(OFST-1,sp)
2600  ee48 e619          	ld	a,(25,x)
2601  ee4a a40f          	and	a,#15
2603                     ; 1328 	uip_connr->timer = 0;
2604  ee4c 4a            	dec	a
2605  ee4d 272a          	jreq	L706
2606  ee4f 4a            	dec	a
2607  ee50 2748          	jreq	L116
2608  ee52 4a            	dec	a
2609  ee53 2603ccef87    	jreq	L316
2610  ee58 4a            	dec	a
2611  ee59 2603ccf145    	jreq	L526
2612  ee5e 4a            	dec	a
2613  ee5f 2603ccf184    	jreq	L726
2614  ee64 4a            	dec	a
2615  ee65 2603ccf1af    	jreq	L336
2616  ee6a 4a            	dec	a
2617  ee6b 2603ccf1bc    	jreq	L536
2618  ee70 4a            	dec	a
2619  ee71 2603ccf134    	jreq	L326
2620  ee76 ccf21a        	jra	L356
2621  ee79               L706:
2622                     ; 996     case UIP_SYN_RCVD:
2622                     ; 997       // In SYN_RCVD we have sent out a SYNACK in response to a SYN, and we
2622                     ; 998       // are waiting for an ACK that acknowledges the data we sent out the
2622                     ; 999       // last time. Therefore, we want to have the UIP_ACKDATA flag set. If
2622                     ; 1000       // so, we enter the ESTABLISHED state.
2622                     ; 1001       if (uip_flags & UIP_ACKDATA) {
2624  ee79 720102c8f8    	btjf	_uip_flags,#0,L356
2625                     ; 1002         uip_connr->tcpstateflags = UIP_ESTABLISHED;
2627  ee7e a603          	ld	a,#3
2628  ee80 e719          	ld	(25,x),a
2629                     ; 1003         uip_flags = UIP_CONNECTED;
2631  ee82 354002c8      	mov	_uip_flags,#64
2632                     ; 1004         uip_connr->len = 0;
2634  ee86 905f          	clrw	y
2635  ee88 ef10          	ldw	(16,x),y
2636                     ; 1005         if (uip_len > 0) {
2638  ee8a ce0373        	ldw	x,_uip_len
2639  ee8d 2707          	jreq	L7711
2640                     ; 1006           uip_flags |= UIP_NEWDATA;
2642  ee8f 721202c8      	bset	_uip_flags,#1
2643                     ; 1007           uip_add_rcv_nxt(uip_len);
2645  ee93 cde8d4        	call	L545_uip_add_rcv_nxt
2647  ee96               L7711:
2648                     ; 1009         uip_slen = 0;
2651  ee96 5f            	clrw	x
2652                     ; 1010         UIP_APPCALL(); // We may have received data with the SYN
2654                     ; 1011         goto appsend;
2656  ee97 ccef6a        	jp	LC002
2657  ee9a               L116:
2658                     ; 1017     case UIP_SYN_SENT:
2658                     ; 1018       // In SYN_SENT, we wait for a SYNACK that is sent in response to our
2658                     ; 1019       // SYN. The rcv_nxt is set to sequence number in the SYNACK plus one,
2658                     ; 1020       // and we send an ACK. We move into the ESTABLISHED state.
2658                     ; 1021       if((uip_flags & UIP_ACKDATA) &&
2658                     ; 1022         (BUF->flags & TCP_CTL) == (TCP_SYN | TCP_ACK)) {
2660  ee9a 720002c803cc  	btjf	_uip_flags,#0,L1021
2662  eea2 c603a6        	ld	a,_uip_buf+47
2663  eea5 a43f          	and	a,#63
2664  eea7 a112          	cp	a,#18
2665  eea9 26f4          	jrne	L1021
2666                     ; 1024         if((BUF->tcpoffset & 0xf0) > 0x50) {
2668  eeab c603a5        	ld	a,_uip_buf+46
2669  eeae a4f0          	and	a,#240
2670  eeb0 a151          	cp	a,#81
2671  eeb2 2403ccef3c    	jrult	L3021
2672                     ; 1025 	  for(c = 0; c < ((BUF->tcpoffset >> 4) - 5) << 2 ;) {
2674  eeb7 725f02a5      	clr	L73_c
2676  eebb 2064          	jra	L1121
2677  eebd               L5021:
2678                     ; 1026 	    opt = uip_buf[UIP_IPTCPH_LEN + UIP_LLH_LEN + c];
2680  eebd 5f            	clrw	x
2681  eebe 97            	ld	xl,a
2682  eebf d603ad        	ld	a,(_uip_buf+54,x)
2683  eec2 c702a4        	ld	L14_opt,a
2684                     ; 1027 	    if(opt == TCP_OPT_END) {
2686  eec5 2775          	jreq	L3021
2687                     ; 1029 	      break;
2689                     ; 1031 	    else if(opt == TCP_OPT_NOOP) {
2691  eec7 a101          	cp	a,#1
2692  eec9 2606          	jrne	L1221
2693                     ; 1032 	      ++c;
2695  eecb 725c02a5      	inc	L73_c
2697  eecf 2050          	jra	L1121
2698  eed1               L1221:
2699                     ; 1035 	    else if(opt == TCP_OPT_MSS &&
2699                     ; 1036 	      uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == TCP_OPT_MSS_LEN) {
2701  eed1 a102          	cp	a,#2
2702  eed3 2639          	jrne	L5221
2704  eed5 c602a5        	ld	a,L73_c
2705  eed8 5f            	clrw	x
2706  eed9 97            	ld	xl,a
2707  eeda d603ae        	ld	a,(_uip_buf+55,x)
2708  eedd a104          	cp	a,#4
2709  eedf 262d          	jrne	L5221
2710                     ; 1038 	      tmp16 = (uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 2 + c] << 8) |
2710                     ; 1039 	        uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 3 + c];
2712  eee1 c602a5        	ld	a,L73_c
2713  eee4 5f            	clrw	x
2714  eee5 97            	ld	xl,a
2715  eee6 d603af        	ld	a,(_uip_buf+56,x)
2716  eee9 97            	ld	xl,a
2717  eeea c602a5        	ld	a,L73_c
2718  eeed 905f          	clrw	y
2719  eeef 9097          	ld	yl,a
2720  eef1 90d603b0      	ld	a,(_uip_buf+57,y)
2721  eef5 02            	rlwa	x,a
2722  eef6 cf02a2        	ldw	L34_tmp16,x
2723                     ; 1040 	      uip_connr->initialmss =
2723                     ; 1041 	        uip_connr->mss = tmp16 > UIP_TCP_MSS? UIP_TCP_MSS: tmp16;
2725  eef9 a301b9        	cpw	x,#441
2726  eefc 2503          	jrult	L451
2727  eefe ae01b8        	ldw	x,#440
2728  ef01               L451:
2729  ef01 1604          	ldw	y,(OFST-1,sp)
2730  ef03 90ef12        	ldw	(18,y),x
2731  ef06 93            	ldw	x,y
2732  ef07 90ee12        	ldw	y,(18,y)
2733  ef0a ef14          	ldw	(20,x),y
2734                     ; 1044 	      break;
2736  ef0c 202e          	jra	L3021
2737  ef0e               L5221:
2738                     ; 1049 	      if(uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == 0) {
2740  ef0e c602a5        	ld	a,L73_c
2741  ef11 5f            	clrw	x
2742  ef12 97            	ld	xl,a
2743  ef13 724d03ae      	tnz	(_uip_buf+55,x)
2744  ef17 2723          	jreq	L3021
2745                     ; 1052 	        break;
2747                     ; 1054 	      c += uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c];
2749  ef19 5f            	clrw	x
2750  ef1a 97            	ld	xl,a
2751  ef1b db03ae        	add	a,(_uip_buf+55,x)
2752  ef1e c702a5        	ld	L73_c,a
2753  ef21               L1121:
2754                     ; 1025 	  for(c = 0; c < ((BUF->tcpoffset >> 4) - 5) << 2 ;) {
2756  ef21 c603a5        	ld	a,_uip_buf+46
2757  ef24 4e            	swap	a
2758  ef25 a40f          	and	a,#15
2759  ef27 5f            	clrw	x
2760  ef28 97            	ld	xl,a
2761  ef29 58            	sllw	x
2762  ef2a 58            	sllw	x
2763  ef2b 1d0014        	subw	x,#20
2764  ef2e c602a5        	ld	a,L73_c
2765  ef31 905f          	clrw	y
2766  ef33 9097          	ld	yl,a
2767  ef35 90bf07        	ldw	c_y,y
2768  ef38 b307          	cpw	x,c_y
2769  ef3a 2c81          	jrsgt	L5021
2770  ef3c               L3021:
2771                     ; 1058         uip_connr->tcpstateflags = UIP_ESTABLISHED;
2773  ef3c 1e04          	ldw	x,(OFST-1,sp)
2774  ef3e a603          	ld	a,#3
2775  ef40 e719          	ld	(25,x),a
2776                     ; 1059         uip_connr->rcv_nxt[0] = BUF->seqno[0];
2778  ef42 c6039d        	ld	a,_uip_buf+38
2779  ef45 e708          	ld	(8,x),a
2780                     ; 1060         uip_connr->rcv_nxt[1] = BUF->seqno[1];
2782  ef47 c6039e        	ld	a,_uip_buf+39
2783  ef4a e709          	ld	(9,x),a
2784                     ; 1061         uip_connr->rcv_nxt[2] = BUF->seqno[2];
2786  ef4c c6039f        	ld	a,_uip_buf+40
2787  ef4f e70a          	ld	(10,x),a
2788                     ; 1062         uip_connr->rcv_nxt[3] = BUF->seqno[3];
2790  ef51 c603a0        	ld	a,_uip_buf+41
2791  ef54 e70b          	ld	(11,x),a
2792                     ; 1063         uip_add_rcv_nxt(1);
2794  ef56 ae0001        	ldw	x,#1
2795  ef59 cde8d4        	call	L545_uip_add_rcv_nxt
2797                     ; 1068         uip_flags = UIP_CONNECTED | UIP_NEWDATA;
2799  ef5c 354202c8      	mov	_uip_flags,#66
2800                     ; 1069         uip_connr->len = 0;
2802  ef60 1e04          	ldw	x,(OFST-1,sp)
2803  ef62 905f          	clrw	y
2804  ef64 ef10          	ldw	(16,x),y
2805                     ; 1070         uip_len = 0;
2807  ef66 5f            	clrw	x
2808  ef67 cf0373        	ldw	_uip_len,x
2809                     ; 1071         uip_slen = 0;
2811  ef6a               LC002:
2812  ef6a cf02b4        	ldw	_uip_slen,x
2813                     ; 1072         UIP_APPCALL(); // This checks to see if there is any data to send with
2815                     ; 1075         goto appsend;
2817  ef6d cce9ef        	jra	L716
2818  ef70               L1021:
2819                     ; 1078       uip_flags = UIP_ABORT;
2821  ef70 352002c8      	mov	_uip_flags,#32
2822                     ; 1082       UIP_APPCALL(); // ???
2824  ef74 cdf64c        	call	_uip_TcpAppHubCall
2826                     ; 1084       uip_conn->tcpstateflags = UIP_CLOSED;
2828  ef77 ce0371        	ldw	x,_uip_conn
2829  ef7a 6f19          	clr	(25,x)
2830                     ; 1085       goto reset;
2831  ef7c               L575:
2832                     ; 734   reset:
2832                     ; 735   // We do not send resets in response to resets.
2832                     ; 736   if (BUF->flags & TCP_RST) goto drop;
2834  ef7c 720403a603cc  	btjf	_uip_buf+47,#2,L5401
2837  ef84 ccf21a        	jra	L356
2838  ef87               L316:
2839                     ; 1089     case UIP_ESTABLISHED:
2839                     ; 1090       // In the ESTABLISHED state, we call upon the application to feed data
2839                     ; 1091       // into the uip_buf. If the UIP_ACKDATA flag is set, the application
2839                     ; 1092       // should put new data into the buffer, otherwise we are retransmitting
2839                     ; 1093       // an old segment, and the application should put that data into the
2839                     ; 1094       // buffer.
2839                     ; 1095       //
2839                     ; 1096       // If the incoming packet is a FIN, we should close the connection on
2839                     ; 1097       // this side as well, and we send out a FIN and enter the LAST_ACK
2839                     ; 1098       // state. We require that there is no outstanding data; otherwise the
2839                     ; 1099       // sequence numbers will be screwed up.
2839                     ; 1100       if (BUF->flags & TCP_FIN && !(uip_connr->tcpstateflags & UIP_STOPPED)) {
2841  ef87 720103a630    	btjf	_uip_buf+47,#0,L3321
2843  ef8c e619          	ld	a,(25,x)
2844  ef8e a510          	bcp	a,#16
2845  ef90 262a          	jrne	L3321
2846                     ; 1101         if (uip_outstanding(uip_connr)) {
2848  ef92 e611          	ld	a,(17,x)
2849  ef94 ea10          	or	a,(16,x)
2850  ef96 26ec          	jrne	L356
2851                     ; 1102           goto drop;
2853                     ; 1104         uip_add_rcv_nxt(1 + uip_len);
2855  ef98 ce0373        	ldw	x,_uip_len
2856  ef9b 5c            	incw	x
2857  ef9c cde8d4        	call	L545_uip_add_rcv_nxt
2859                     ; 1105         uip_flags |= UIP_CLOSE;
2861  ef9f 721802c8      	bset	_uip_flags,#4
2862                     ; 1106         if (uip_len > 0) {
2864  efa3 ce0373        	ldw	x,_uip_len
2865  efa6 2704          	jreq	L7321
2866                     ; 1107           uip_flags |= UIP_NEWDATA;
2868  efa8 721202c8      	bset	_uip_flags,#1
2869  efac               L7321:
2870                     ; 1109         UIP_APPCALL(); // This processes any receive data and sets up any
2872  efac cdf64c        	call	_uip_TcpAppHubCall
2874                     ; 1111 	uip_connr->len = 1;
2876  efaf 1e04          	ldw	x,(OFST-1,sp)
2877  efb1 90ae0001      	ldw	y,#1
2878  efb5 ef10          	ldw	(16,x),y
2879                     ; 1112         uip_connr->tcpstateflags = UIP_LAST_ACK;
2881  efb7 a608          	ld	a,#8
2882                     ; 1113         uip_connr->nrtx = 0;
2883                     ; 1115         tcp_send_finack:
2883                     ; 1116 	BUF->flags = TCP_FIN | TCP_ACK;
2884                     ; 1117         goto tcp_send_nodata;
2886  efb9 ccf049        	jp	LC006
2887  efbc               L3321:
2888                     ; 1122       if ((BUF->flags & TCP_URG) != 0) {
2890  efbc 720b03a61f    	btjf	_uip_buf+47,#5,L1421
2891                     ; 1123         uip_appdata = ((char *)uip_appdata) + ((BUF->urgp[0] << 8) | BUF->urgp[1]);
2893  efc1 c603ab        	ld	a,_uip_buf+52
2894  efc4 97            	ld	xl,a
2895  efc5 c603ac        	ld	a,_uip_buf+53
2896  efc8 02            	rlwa	x,a
2897  efc9 72bb0375      	addw	x,_uip_appdata
2898  efcd cf0375        	ldw	_uip_appdata,x
2899                     ; 1124         uip_len -= (BUF->urgp[0] << 8) | BUF->urgp[1];
2901  efd0 c603ab        	ld	a,_uip_buf+52
2902  efd3 97            	ld	xl,a
2903  efd4 c603ac        	ld	a,_uip_buf+53
2904  efd7 02            	rlwa	x,a
2905  efd8 72b00373      	subw	x,_uip_len
2906  efdc 50            	negw	x
2907  efdd cf0373        	ldw	_uip_len,x
2908  efe0               L1421:
2909                     ; 1132       if (uip_len > 0 && !(uip_connr->tcpstateflags & UIP_STOPPED)) {
2911  efe0 ce0373        	ldw	x,_uip_len
2912  efe3 2712          	jreq	L3421
2914  efe5 1e04          	ldw	x,(OFST-1,sp)
2915  efe7 e619          	ld	a,(25,x)
2916  efe9 a510          	bcp	a,#16
2917  efeb 260a          	jrne	L3421
2918                     ; 1133         uip_flags |= UIP_NEWDATA;
2920  efed 721202c8      	bset	_uip_flags,#1
2921                     ; 1134         uip_add_rcv_nxt(uip_len);
2923  eff1 ce0373        	ldw	x,_uip_len
2924  eff4 cde8d4        	call	L545_uip_add_rcv_nxt
2926  eff7               L3421:
2927                     ; 1147       tmp16 = ((uint16_t)BUF->wnd[0] << 8) + (uint16_t)BUF->wnd[1];
2929  eff7 c603a8        	ld	a,_uip_buf+49
2930  effa 5f            	clrw	x
2931  effb 97            	ld	xl,a
2932  effc 1f01          	ldw	(OFST-4,sp),x
2934  effe c603a7        	ld	a,_uip_buf+48
2935  f001 97            	ld	xl,a
2936  f002 4f            	clr	a
2937  f003 02            	rlwa	x,a
2938  f004 72fb01        	addw	x,(OFST-4,sp)
2939  f007 cf02a2        	ldw	L34_tmp16,x
2940                     ; 1148       if (tmp16 > uip_connr->initialmss || tmp16 == 0) {
2942  f00a 1604          	ldw	y,(OFST-1,sp)
2943  f00c 90ee14        	ldw	y,(20,y)
2944  f00f 90c302a2      	cpw	y,L34_tmp16
2945  f013 2505          	jrult	L7421
2947  f015 ce02a2        	ldw	x,L34_tmp16
2948  f018 2607          	jrne	L5421
2949  f01a               L7421:
2950                     ; 1149         tmp16 = uip_connr->initialmss;
2952  f01a 1e04          	ldw	x,(OFST-1,sp)
2953  f01c ee14          	ldw	x,(20,x)
2954  f01e cf02a2        	ldw	L34_tmp16,x
2955  f021               L5421:
2956                     ; 1151       uip_connr->mss = tmp16;
2958  f021 1e04          	ldw	x,(OFST-1,sp)
2959  f023 90ce02a2      	ldw	y,L34_tmp16
2960  f027 ef12          	ldw	(18,x),y
2961                     ; 1168       if (uip_flags & (UIP_NEWDATA | UIP_ACKDATA)) {
2963  f029 c602c8        	ld	a,_uip_flags
2964  f02c a503          	bcp	a,#3
2965  f02e 2603ccf21a    	jreq	L356
2966                     ; 1169         uip_slen = 0;
2967                     ; 1170         UIP_APPCALL(); // Here is where the application will read data that
2969  f033 ccee96        	jp	L7711
2970  f036               L3521:
2971                     ; 1187         if (uip_flags & UIP_CLOSE) {
2973  f036 720902c81e    	btjf	_uip_flags,#4,L5521
2974                     ; 1188           uip_slen = 0;
2976  f03b 5f            	clrw	x
2977  f03c cf02b4        	ldw	_uip_slen,x
2978                     ; 1189 	  uip_connr->len = 1;
2980  f03f 1e04          	ldw	x,(OFST-1,sp)
2981  f041 90ae0001      	ldw	y,#1
2982  f045 ef10          	ldw	(16,x),y
2983                     ; 1190 	  uip_connr->tcpstateflags = UIP_FIN_WAIT_1;
2985  f047 a604          	ld	a,#4
2986                     ; 1191 	  uip_connr->nrtx = 0;
2988  f049               LC006:
2989  f049 e719          	ld	(25,x),a
2991  f04b 6f1b          	clr	(27,x)
2992                     ; 1192 	  BUF->flags = TCP_FIN | TCP_ACK;
2994  f04d               LC004:
2996  f04d 351103a6      	mov	_uip_buf+47,#17
2997                     ; 1193 	  goto tcp_send_nodata;
2998  f051               L736:
2999                     ; 1342   tcp_send_nodata:
2999                     ; 1343   uip_len = UIP_IPTCPH_LEN;
3001  f051 ae0028        	ldw	x,#40
3002  f054 cf0373        	ldw	_uip_len,x
3003  f057 206e          	jra	L146
3004  f059               L5521:
3005                     ; 1197         if (uip_slen > 0) {
3007  f059 ce02b4        	ldw	x,_uip_slen
3008  f05c 2732          	jreq	L7521
3009                     ; 1200 	  if ((uip_flags & UIP_ACKDATA) != 0) {
3011  f05e 720102c806    	btjf	_uip_flags,#0,L1621
3012                     ; 1201 	    uip_connr->len = 0;
3014  f063 1e04          	ldw	x,(OFST-1,sp)
3015  f065 905f          	clrw	y
3016  f067 ef10          	ldw	(16,x),y
3017  f069               L1621:
3018                     ; 1206 	  if (uip_connr->len == 0) {
3020  f069 1e04          	ldw	x,(OFST-1,sp)
3021  f06b e611          	ld	a,(17,x)
3022  f06d ea10          	or	a,(16,x)
3023  f06f 261a          	jrne	L3621
3024                     ; 1209 	    if (uip_slen > uip_connr->mss) {
3026  f071 9093          	ldw	y,x
3027  f073 90ee12        	ldw	y,(18,y)
3028  f076 90c302b4      	cpw	y,_uip_slen
3029  f07a 2407          	jruge	L5621
3030                     ; 1210 	      uip_slen = uip_connr->mss;
3032  f07c ee12          	ldw	x,(18,x)
3033  f07e cf02b4        	ldw	_uip_slen,x
3034  f081 1e04          	ldw	x,(OFST-1,sp)
3035  f083               L5621:
3036                     ; 1215             uip_connr->len = uip_slen;
3038  f083 90ce02b4      	ldw	y,_uip_slen
3039  f087 ef10          	ldw	(16,x),y
3041  f089 2005          	jra	L7521
3042  f08b               L3621:
3043                     ; 1221 	    uip_slen = uip_connr->len;
3045  f08b ee10          	ldw	x,(16,x)
3046  f08d cf02b4        	ldw	_uip_slen,x
3047  f090               L7521:
3048                     ; 1224 	uip_connr->nrtx = 0;
3050  f090 1e04          	ldw	x,(OFST-1,sp)
3051  f092 6f1b          	clr	(27,x)
3052  f094               L126:
3053                     ; 1229 	apprexmit:
3053                     ; 1230 	uip_appdata = uip_sappdata;
3055  f094 ce02b6        	ldw	x,_uip_sappdata
3056  f097 cf0375        	ldw	_uip_appdata,x
3057                     ; 1234 	if (uip_slen > 0 && uip_connr->len > 0) {
3059  f09a ce02b4        	ldw	x,_uip_slen
3060  f09d 2716          	jreq	L1721
3062  f09f 1e04          	ldw	x,(OFST-1,sp)
3063  f0a1 e611          	ld	a,(17,x)
3064  f0a3 ea10          	or	a,(16,x)
3065  f0a5 270e          	jreq	L1721
3066                     ; 1236 	  uip_len = uip_connr->len + UIP_TCPIP_HLEN;
3068  f0a7 ee10          	ldw	x,(16,x)
3069  f0a9 1c0028        	addw	x,#40
3070  f0ac cf0373        	ldw	_uip_len,x
3071                     ; 1238 	  BUF->flags = TCP_ACK | TCP_PSH;
3073  f0af 351803a6      	mov	_uip_buf+47,#24
3074                     ; 1240 	  goto tcp_send_noopts;
3076  f0b3 2012          	jra	L146
3077  f0b5               L1721:
3078                     ; 1244 	if (uip_flags & UIP_NEWDATA) {
3080  f0b5 720202c803cc  	btjf	_uip_flags,#1,L356
3081                     ; 1245 	  uip_len = UIP_TCPIP_HLEN;
3083  f0bd ae0028        	ldw	x,#40
3084  f0c0 cf0373        	ldw	_uip_len,x
3085                     ; 1246 	  BUF->flags = TCP_ACK;
3087  f0c3 351003a6      	mov	_uip_buf+47,#16
3088                     ; 1247 	  goto tcp_send_noopts;
3089  f0c7               L146:
3090                     ; 1345   tcp_send_noopts:
3090                     ; 1346   BUF->tcpoffset = (UIP_TCPH_LEN / 4) << 4;
3092  f0c7 355003a5      	mov	_uip_buf+46,#80
3093  f0cb               L346:
3094                     ; 1351   tcp_send:
3094                     ; 1352   // We're done with the input processing. We are now ready to send a reply.
3094                     ; 1353   // Our job is to fill in all the fields of the TCP and IP headers before
3094                     ; 1354   // calculating the checksum and finally send the packet.
3094                     ; 1355   BUF->ackno[0] = uip_connr->rcv_nxt[0];
3096  f0cb 1e04          	ldw	x,(OFST-1,sp)
3097  f0cd e608          	ld	a,(8,x)
3098  f0cf c703a1        	ld	_uip_buf+42,a
3099                     ; 1356   BUF->ackno[1] = uip_connr->rcv_nxt[1];
3101  f0d2 e609          	ld	a,(9,x)
3102  f0d4 c703a2        	ld	_uip_buf+43,a
3103                     ; 1357   BUF->ackno[2] = uip_connr->rcv_nxt[2];
3105  f0d7 e60a          	ld	a,(10,x)
3106  f0d9 c703a3        	ld	_uip_buf+44,a
3107                     ; 1358   BUF->ackno[3] = uip_connr->rcv_nxt[3];
3109  f0dc e60b          	ld	a,(11,x)
3110  f0de c703a4        	ld	_uip_buf+45,a
3111                     ; 1360   BUF->seqno[0] = uip_connr->snd_nxt[0];
3113  f0e1 e60c          	ld	a,(12,x)
3114  f0e3 c7039d        	ld	_uip_buf+38,a
3115                     ; 1361   BUF->seqno[1] = uip_connr->snd_nxt[1];
3117  f0e6 e60d          	ld	a,(13,x)
3118  f0e8 c7039e        	ld	_uip_buf+39,a
3119                     ; 1362   BUF->seqno[2] = uip_connr->snd_nxt[2];
3121  f0eb e60e          	ld	a,(14,x)
3122  f0ed c7039f        	ld	_uip_buf+40,a
3123                     ; 1363   BUF->seqno[3] = uip_connr->snd_nxt[3];
3125  f0f0 e60f          	ld	a,(15,x)
3126  f0f2 c703a0        	ld	_uip_buf+41,a
3127                     ; 1365   BUF->proto = UIP_PROTO_TCP;
3129  f0f5 3506038e      	mov	_uip_buf+23,#6
3130                     ; 1367   BUF->srcport = uip_connr->lport;
3132  f0f9 ee04          	ldw	x,(4,x)
3133  f0fb cf0399        	ldw	_uip_buf+34,x
3134                     ; 1368   BUF->destport = uip_connr->rport;
3136  f0fe 1e04          	ldw	x,(OFST-1,sp)
3137  f100 ee06          	ldw	x,(6,x)
3138  f102 cf039b        	ldw	_uip_buf+36,x
3139                     ; 1370   uip_ipaddr_copy(BUF->srcipaddr, uip_hostaddr);
3141  f105 ce02c4        	ldw	x,_uip_hostaddr
3142  f108 cf0391        	ldw	_uip_buf+26,x
3145  f10b ce02c6        	ldw	x,_uip_hostaddr+2
3146  f10e cf0393        	ldw	_uip_buf+28,x
3147                     ; 1371   uip_ipaddr_copy(BUF->destipaddr, uip_connr->ripaddr);
3149  f111 1e04          	ldw	x,(OFST-1,sp)
3150  f113 fe            	ldw	x,(x)
3151  f114 cf0395        	ldw	_uip_buf+30,x
3154  f117 1e04          	ldw	x,(OFST-1,sp)
3155  f119 ee02          	ldw	x,(2,x)
3156  f11b cf0397        	ldw	_uip_buf+32,x
3157                     ; 1373   if (uip_connr->tcpstateflags & UIP_STOPPED) {
3159  f11e 1e04          	ldw	x,(OFST-1,sp)
3160  f120 e619          	ld	a,(25,x)
3161  f122 a510          	bcp	a,#16
3162  f124 2603ccf1c3    	jreq	L5331
3163                     ; 1376     BUF->wnd[0] = BUF->wnd[1] = 0;
3165  f129 725f03a8      	clr	_uip_buf+49
3166  f12d 725f03a7      	clr	_uip_buf+48
3168  f131 ccf1cb        	jra	L546
3169  f134               L326:
3170                     ; 1252     case UIP_LAST_ACK:
3170                     ; 1253       // We can close this connection if the peer has acknowledged our FIN.
3170                     ; 1254       // This is indicated by the UIP_ACKDATA flag.
3170                     ; 1255       if (uip_flags & UIP_ACKDATA) {
3172  f134 720102c881    	btjf	_uip_flags,#0,L356
3173                     ; 1256         uip_connr->tcpstateflags = UIP_CLOSED;
3175  f139 e719          	ld	(25,x),a
3176                     ; 1257 	uip_flags = UIP_CLOSE;
3178  f13b 351002c8      	mov	_uip_flags,#16
3179                     ; 1262 	UIP_APPCALL(); // ???
3181  f13f cdf64c        	call	_uip_TcpAppHubCall
3183  f142 ccf21a        	jra	L356
3184  f145               L526:
3185                     ; 1266     case UIP_FIN_WAIT_1:
3185                     ; 1267       // The application has closed the connection, but the remote host hasn't
3185                     ; 1268       // closed its end yet. Thus we do nothing but wait for a FIN from the
3185                     ; 1269       // other side.
3185                     ; 1270       if (uip_len > 0) {
3187  f145 ce0373        	ldw	x,_uip_len
3188  f148 2703          	jreq	L7721
3189                     ; 1271         uip_add_rcv_nxt(uip_len);
3191  f14a cde8d4        	call	L545_uip_add_rcv_nxt
3193  f14d               L7721:
3194                     ; 1273       if (BUF->flags & TCP_FIN) {
3196  f14d 720103a619    	btjf	_uip_buf+47,#0,L1031
3197                     ; 1274         if (uip_flags & UIP_ACKDATA) {
3199  f152 1e04          	ldw	x,(OFST-1,sp)
3200  f154 720102c80c    	btjf	_uip_flags,#0,L3031
3201                     ; 1275 	  uip_connr->tcpstateflags = UIP_TIME_WAIT;
3203  f159 a607          	ld	a,#7
3204  f15b e719          	ld	(25,x),a
3205                     ; 1276 	  uip_connr->timer = 0;
3207  f15d 6f1a          	clr	(26,x)
3208                     ; 1277 	  uip_connr->len = 0;
3210  f15f 905f          	clrw	y
3211  f161 ef10          	ldw	(16,x),y
3213  f163 2034          	jra	LC005
3214  f165               L3031:
3215                     ; 1280           uip_connr->tcpstateflags = UIP_CLOSING;
3217  f165 a606          	ld	a,#6
3218  f167 e719          	ld	(25,x),a
3219                     ; 1282         uip_add_rcv_nxt(1);
3221                     ; 1283         uip_flags = UIP_CLOSE;
3222                     ; 1288         UIP_APPCALL(); // ???
3224                     ; 1289         goto tcp_send_ack;
3226  f169 202e          	jp	LC005
3227  f16b               L1031:
3228                     ; 1291       else if (uip_flags & UIP_ACKDATA) {
3230  f16b 720102c80d    	btjf	_uip_flags,#0,L7031
3231                     ; 1292         uip_connr->tcpstateflags = UIP_FIN_WAIT_2;
3233  f170 1e04          	ldw	x,(OFST-1,sp)
3234  f172 a605          	ld	a,#5
3235  f174 e719          	ld	(25,x),a
3236                     ; 1293         uip_connr->len = 0;
3238  f176 905f          	clrw	y
3239  f178 ef10          	ldw	(16,x),y
3240                     ; 1294         goto drop;
3242  f17a ccf21a        	jra	L356
3243  f17d               L7031:
3244                     ; 1296       if (uip_len > 0) {
3246  f17d ce0373        	ldw	x,_uip_len
3247  f180 27f8          	jreq	L356
3248                     ; 1297         goto tcp_send_ack;
3250  f182 2038          	jra	L536
3251  f184               L726:
3252                     ; 1301     case UIP_FIN_WAIT_2:
3252                     ; 1302       if (uip_len > 0) {
3254  f184 ce0373        	ldw	x,_uip_len
3255  f187 2703          	jreq	L5131
3256                     ; 1303 	uip_add_rcv_nxt(uip_len);
3258  f189 cde8d4        	call	L545_uip_add_rcv_nxt
3260  f18c               L5131:
3261                     ; 1305       if (BUF->flags & TCP_FIN) {
3263  f18c 720103a617    	btjf	_uip_buf+47,#0,L7131
3264                     ; 1306 	uip_connr->tcpstateflags = UIP_TIME_WAIT;
3266  f191 1e04          	ldw	x,(OFST-1,sp)
3267  f193 a607          	ld	a,#7
3268  f195 e719          	ld	(25,x),a
3269                     ; 1307 	uip_connr->timer = 0;
3271  f197 6f1a          	clr	(26,x)
3272                     ; 1308 	uip_add_rcv_nxt(1);
3275                     ; 1309 	uip_flags = UIP_CLOSE;
3277                     ; 1314 	UIP_APPCALL(); // ???
3279  f199               LC005:
3281  f199 ae0001        	ldw	x,#1
3282  f19c cde8d4        	call	L545_uip_add_rcv_nxt
3284  f19f 351002c8      	mov	_uip_flags,#16
3286  f1a3 cdf64c        	call	_uip_TcpAppHubCall
3288                     ; 1315 	goto tcp_send_ack;
3290  f1a6 2014          	jra	L536
3291  f1a8               L7131:
3292                     ; 1317       if (uip_len > 0) {
3294  f1a8 ce0373        	ldw	x,_uip_len
3295  f1ab 276d          	jreq	L356
3296                     ; 1318 	goto tcp_send_ack;
3298  f1ad 200d          	jra	L536
3299  f1af               L336:
3300                     ; 1325     case UIP_CLOSING:
3300                     ; 1326       if (uip_flags & UIP_ACKDATA) {
3302  f1af 720102c866    	btjf	_uip_flags,#0,L356
3303                     ; 1327 	uip_connr->tcpstateflags = UIP_TIME_WAIT;
3305  f1b4 a607          	ld	a,#7
3306  f1b6 e719          	ld	(25,x),a
3307                     ; 1328 	uip_connr->timer = 0;
3309  f1b8 6f1a          	clr	(26,x)
3310  f1ba 205e          	jra	L356
3311                     ; 1331   goto drop;
3313  f1bc               L536:
3314                     ; 1337   tcp_send_ack:
3314                     ; 1338   // We jump here when we are ready to send the packet, and just want to set
3314                     ; 1339   // the appropriate TCP sequence numbers in the TCP header.
3314                     ; 1340   BUF->flags = TCP_ACK;
3316  f1bc 351003a6      	mov	_uip_buf+47,#16
3317  f1c0 ccf051        	jra	L736
3318  f1c3               L5331:
3319                     ; 1381     BUF->wnd[0] = ((UIP_RECEIVE_WINDOW) >> 8);
3321  f1c3 350103a7      	mov	_uip_buf+48,#1
3322                     ; 1382     BUF->wnd[1] = ((UIP_RECEIVE_WINDOW) & 0xff);
3324  f1c7 35b803a8      	mov	_uip_buf+49,#184
3325  f1cb               L546:
3326                     ; 1389   tcp_send_noconn:
3326                     ; 1390   BUF->ttl = UIP_TTL;
3328  f1cb 3540038d      	mov	_uip_buf+22,#64
3329                     ; 1391   BUF->len[0] = (uint8_t)(uip_len >> 8);
3331  f1cf 5503730387    	mov	_uip_buf+16,_uip_len
3332                     ; 1392   BUF->len[1] = (uint8_t)(uip_len & 0xff);
3334  f1d4 5503740388    	mov	_uip_buf+17,_uip_len+1
3335                     ; 1394   BUF->urgp[0] = BUF->urgp[1] = 0;
3337  f1d9 725f03ac      	clr	_uip_buf+53
3338  f1dd 725f03ab      	clr	_uip_buf+52
3339                     ; 1397   BUF->tcpchksum = 0;
3341  f1e1 5f            	clrw	x
3342  f1e2 cf03a9        	ldw	_uip_buf+50,x
3343                     ; 1398   BUF->tcpchksum = ~(uip_tcpchksum());
3345  f1e5 cde7e2        	call	_uip_tcpchksum
3347  f1e8 53            	cplw	x
3348  f1e9 cf03a9        	ldw	_uip_buf+50,x
3349                     ; 1403   ip_send_nolen:
3349                     ; 1404 
3349                     ; 1405   BUF->vhl = 0x45;
3351  f1ec 35450385      	mov	_uip_buf+14,#69
3352                     ; 1406   BUF->tos = 0;
3354  f1f0 725f0386      	clr	_uip_buf+15
3355                     ; 1407   BUF->ipoffset[0] = BUF->ipoffset[1] = 0;
3357  f1f4 725f038c      	clr	_uip_buf+21
3358  f1f8 725f038b      	clr	_uip_buf+20
3359                     ; 1408   ++ipid;
3361  f1fc ce02aa        	ldw	x,L11_ipid
3362  f1ff 5c            	incw	x
3363  f200 cf02aa        	ldw	L11_ipid,x
3364                     ; 1409   BUF->ipid[0] = (uint8_t)(ipid >> 8);
3366  f203 5502aa0389    	mov	_uip_buf+18,L11_ipid
3367                     ; 1410   BUF->ipid[1] = (uint8_t)(ipid & 0xff);
3369  f208 5502ab038a    	mov	_uip_buf+19,L11_ipid+1
3370                     ; 1412   BUF->ipchksum = 0;
3372  f20d 5f            	clrw	x
3373  f20e cf038f        	ldw	_uip_buf+24,x
3374                     ; 1413   BUF->ipchksum = ~(uip_ipchksum());
3376  f211 cde77c        	call	_uip_ipchksum
3378  f214 53            	cplw	x
3379  f215 cf038f        	ldw	_uip_buf+24,x
3381  f218 2004          	jra	L222
3382  f21a               L356:
3383                     ; 1430   drop:
3383                     ; 1431   uip_len = 0;
3385  f21a 5f            	clrw	x
3386  f21b cf0373        	ldw	_uip_len,x
3387                     ; 1432   uip_flags = 0;
3389                     ; 1433   return;
3390  f21e               L222:
3392  f21e 725f02c8      	clr	_uip_flags
3395  f222 5b06          	addw	sp,#6
3396  f224 81            	ret	
3428                     ; 1438 uint16_t htons(uint16_t val)
3428                     ; 1439 {
3429                     .text:	section	.text,new
3430  f225               _htons:
3434                     ; 1440   return HTONS(val);
3438  f225 81            	ret	
3483                     ; 1446 void uip_send(const char *data, int len)
3483                     ; 1447 {
3484                     .text:	section	.text,new
3485  f226               _uip_send:
3487  f226 89            	pushw	x
3488       00000000      OFST:	set	0
3491                     ; 1448   if (len > 0) {
3493  f227 9c            	rvf	
3494  f228 1e05          	ldw	x,(OFST+5,sp)
3495  f22a 2d1c          	jrsle	L032
3496                     ; 1449     uip_slen = len;
3498  f22c cf02b4        	ldw	_uip_slen,x
3499                     ; 1450     if (data != uip_sappdata) {
3501  f22f 1e01          	ldw	x,(OFST+1,sp)
3502  f231 c302b6        	cpw	x,_uip_sappdata
3503  f234 2712          	jreq	L032
3504                     ; 1451       memcpy(uip_sappdata, (data), uip_slen);
3506  f236 bf04          	ldw	c_x,x
3507  f238 ce02b4        	ldw	x,_uip_slen
3508  f23b 270b          	jreq	L032
3509  f23d               L232:
3510  f23d 5a            	decw	x
3511  f23e 92d604        	ld	a,([c_x.w],x)
3512  f241 72d702b6      	ld	([_uip_sappdata.w],x),a
3513  f245 5d            	tnzw	x
3514  f246 26f5          	jrne	L232
3515  f248               L032:
3516                     ; 1454 }
3519  f248 85            	popw	x
3520  f249 81            	ret	
3735                     	switch	.bss
3736  02a2               L34_tmp16:
3737  02a2 0000          	ds.b	2
3738  02a4               L14_opt:
3739  02a4 00            	ds.b	1
3740  02a5               L73_c:
3741  02a5 00            	ds.b	1
3742  02a6               L53_iss:
3743  02a6 00000000      	ds.b	4
3744  02aa               L11_ipid:
3745  02aa 0000          	ds.b	2
3746  02ac               _uip_listenports:
3747  02ac 000000000000  	ds.b	8
3748                     	xdef	_uip_listenports
3749  02b4               _uip_slen:
3750  02b4 0000          	ds.b	2
3751                     	xdef	_uip_slen
3752  02b6               _uip_sappdata:
3753  02b6 0000          	ds.b	2
3754                     	xdef	_uip_sappdata
3755                     	xdef	_uip_ethaddr
3756                     	xdef	_uip_add32
3757                     	xdef	_uip_tcpchksum
3758                     	xdef	_uip_ipchksum
3759                     	xdef	_uip_chksum
3760  02b8               _uip_mqttserveraddr:
3761  02b8 00000000      	ds.b	4
3762                     	xdef	_uip_mqttserveraddr
3763  02bc               _uip_draddr:
3764  02bc 00000000      	ds.b	4
3765                     	xdef	_uip_draddr
3766  02c0               _uip_netmask:
3767  02c0 00000000      	ds.b	4
3768                     	xdef	_uip_netmask
3769  02c4               _uip_hostaddr:
3770  02c4 00000000      	ds.b	4
3771                     	xdef	_uip_hostaddr
3772                     	xdef	_uip_process
3773  02c8               _uip_flags:
3774  02c8 00            	ds.b	1
3775                     	xdef	_uip_flags
3776  02c9               _uip_acc32:
3777  02c9 00000000      	ds.b	4
3778                     	xdef	_uip_acc32
3779  02cd               _uip_conns:
3780  02cd 000000000000  	ds.b	164
3781                     	xdef	_uip_conns
3782  0371               _uip_conn:
3783  0371 0000          	ds.b	2
3784                     	xdef	_uip_conn
3785  0373               _uip_len:
3786  0373 0000          	ds.b	2
3787                     	xdef	_uip_len
3788  0375               _uip_appdata:
3789  0375 0000          	ds.b	2
3790                     	xdef	_uip_appdata
3791                     	xdef	_htons
3792                     	xdef	_uip_send
3793                     	xdef	_uip_connect
3794                     	xdef	_uip_unlisten
3795                     	xdef	_uip_listen
3796  0377               _uip_buf:
3797  0377 000000000000  	ds.b	502
3798                     	xdef	_uip_buf
3799                     	xdef	_uip_setipid
3800                     	xdef	_uip_init_stats
3801                     	xdef	_uip_init
3802                     	xref	_uip_TcpAppHubCall
3803                     	xref.b	c_x
3804                     	xref.b	c_y
3824                     	end
