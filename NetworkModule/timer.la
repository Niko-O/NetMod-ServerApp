   1                     ; C Compiler for STM8 (COSMIC Software)
   2                     ; Parser V4.11.14 - 18 Nov 2019
   3                     ; Generator (Limited) V4.4.11 - 19 Nov 2019
   4                     ; Optimizer V4.4.11 - 19 Nov 2019
2565                     ; 42 void clock_init(void)
2565                     ; 43 {
2567                     .text:	section	.text,new
2568  e538               _clock_init:
2572                     ; 86   CLK_ICKR = ((uint8_t)0x01);
2574  e538 350150c0      	mov	_CLK_ICKR,#1
2575                     ; 87   CLK_ECKR = ((uint8_t)0x00);
2577  e53c 725f50c1      	clr	_CLK_ECKR
2578                     ; 88   CLK_SWR  = ((uint8_t)0xE1);
2580  e540 35e150c4      	mov	_CLK_SWR,#225
2581                     ; 89   CLK_SWCR = ((uint8_t)0x00);
2583  e544 725f50c5      	clr	_CLK_SWCR
2584                     ; 90   CLK_CKDIVR = ((uint8_t)0x18);
2586  e548 351850c6      	mov	_CLK_CKDIVR,#24
2587                     ; 91   CLK_PCKENR1 = ((uint8_t)0xFF);
2589  e54c 35ff50c7      	mov	_CLK_PCKENR1,#255
2590                     ; 92   CLK_PCKENR2 = ((uint8_t)0xFF);
2592  e550 35ff50ca      	mov	_CLK_PCKENR2,#255
2593                     ; 93   CLK_CSSR = ((uint8_t)0x00);
2595  e554 725f50c8      	clr	_CLK_CSSR
2596                     ; 94   CLK_CCOR = ((uint8_t)0x00);
2598  e558 725f50c9      	clr	_CLK_CCOR
2600  e55c               L1461:
2601                     ; 95   while ((CLK_CCOR & CLK_CCOR_CCOEN)!= 0) {}
2603  e55c 720050c9fb    	btjt	_CLK_CCOR,#0,L1461
2604                     ; 96   CLK_CCOR = ((uint8_t)0x00);
2606  e561 725f50c9      	clr	_CLK_CCOR
2607                     ; 97   CLK_HSITRIMR = ((uint8_t)0x00);
2609  e565 725f50cc      	clr	_CLK_HSITRIMR
2610                     ; 98   CLK_SWIMCCR = ((uint8_t)0x00);
2612  e569 725f50cd      	clr	_CLK_SWIMCCR
2613                     ; 101   CLK_ICKR |= ((uint8_t)0x01); // Enable HSI oscillator (MAY NOT BE NECESSARY AFTER RESET)
2615  e56d 721050c0      	bset	_CLK_ICKR,#0
2617  e571               L7461:
2618                     ; 104   while ((CLK_ICKR & CLK_ICKR_HSIRDY)== 0) {}
2620  e571 720350c0fb    	btjf	_CLK_ICKR,#1,L7461
2621                     ; 107   CLK_SWCR |= CLK_SWCR_SWEN;
2623  e576 721250c5      	bset	_CLK_SWCR,#1
2624                     ; 113   CLK_CKDIVR = (uint8_t)0x00;
2626  e57a 725f50c6      	clr	_CLK_CKDIVR
2627                     ; 126   CLK_PCKENR1 |= (uint8_t)0x80;		// Enable clock to TIM1
2629  e57e 721e50c7      	bset	_CLK_PCKENR1,#7
2630                     ; 127   CLK_PCKENR1 |= (uint8_t)0x20;		// Enable clock to TIM2
2632  e582 721a50c7      	bset	_CLK_PCKENR1,#5
2633                     ; 128   CLK_PCKENR1 |= (uint8_t)0x40;		// Enable clock to TIM3
2635  e586 721c50c7      	bset	_CLK_PCKENR1,#6
2636                     ; 129   CLK_PCKENR1 &= (uint8_t)(~0x10);	// Disable clock to TIM4
2638  e58a 721950c7      	bres	_CLK_PCKENR1,#4
2639                     ; 130   CLK_PCKENR1 &= (uint8_t)(~0x08);	// Disable clock to UART
2641  e58e 721750c7      	bres	_CLK_PCKENR1,#3
2642                     ; 131   CLK_PCKENR1 &= (uint8_t)(~0x02);	// Disable clock to SPI
2644  e592 721350c7      	bres	_CLK_PCKENR1,#1
2645                     ; 132   CLK_PCKENR1 &= (uint8_t)(~0x01);	// Disable clock to I2C
2647  e596 721150c7      	bres	_CLK_PCKENR1,#0
2648                     ; 133   CLK_PCKENR2 &= (uint8_t)(~0x08);	// Disable clock to ADC
2650  e59a 721750ca      	bres	_CLK_PCKENR2,#3
2651                     ; 134   CLK_PCKENR2 &= (uint8_t)(~0x04);	// Disable clock to AWU
2653  e59e 721550ca      	bres	_CLK_PCKENR2,#2
2654                     ; 152   TIM2_PSCR = (uint8_t)0x0e;
2656  e5a2 350e530c      	mov	_TIM2_PSCR,#14
2657                     ; 154   TIM2_CR1 = (uint8_t)0x01;
2659  e5a6 35015300      	mov	_TIM2_CR1,#1
2660                     ; 156   TIM2_EGR = (uint8_t)0x01;
2662  e5aa 35015304      	mov	_TIM2_EGR,#1
2663                     ; 164   TIM3_PSCR = (uint8_t)0x04;
2665  e5ae 3504532a      	mov	_TIM3_PSCR,#4
2666                     ; 166   TIM3_CR1 = (uint8_t)0x01;
2668  e5b2 35015320      	mov	_TIM3_CR1,#1
2669                     ; 168   TIM3_EGR = (uint8_t)0x01;
2671  e5b6 35015324      	mov	_TIM3_EGR,#1
2672                     ; 170   arp_timer = 0x00;   // Initialize arp timer
2674  e5ba 725f02a1      	clr	_arp_timer
2675                     ; 171   second_toggle = 0;  // Initialize toggle for seconds counter
2677  e5be 725f02a0      	clr	_second_toggle
2678                     ; 172   second_counter = 0; // Initialize seconds counter
2680  e5c2 5f            	clrw	x
2681  e5c3 cf029e        	ldw	_second_counter+2,x
2682  e5c6 cf029c        	ldw	_second_counter,x
2683                     ; 173 }
2686  e5c9 81            	ret	
2716                     ; 177 periodic_timer_expired(void)
2716                     ; 178 {
2717                     .text:	section	.text,new
2718  e5ca               _periodic_timer_expired:
2722                     ; 194   if ((uint8_t)TIM2_CNTRL > 0x62) {     // Evaluate at 100ms
2724  e5ca c6530b        	ld	a,_TIM2_CNTRL
2725  e5cd a163          	cp	a,#99
2726  e5cf 2530          	jrult	L3661
2727                     ; 195     TIM2_CR1 &= (uint8_t)(~0x01);	// Disable counter
2729  e5d1 72115300      	bres	_TIM2_CR1,#0
2730                     ; 196     TIM2_CNTRH = (uint8_t)0x00;		// Clear counter High
2732  e5d5 725f530a      	clr	_TIM2_CNTRH
2733                     ; 197     TIM2_CNTRL = (uint8_t)0x00;		// Clear counter Low
2735  e5d9 725f530b      	clr	_TIM2_CNTRL
2736                     ; 198     TIM2_CR1 |= (uint8_t)0x01;		// Enable counter
2738  e5dd 72105300      	bset	_TIM2_CR1,#0
2739                     ; 200     arp_timer++;			// Increment arp_timer every ~100 ms
2741  e5e1 725c02a1      	inc	_arp_timer
2742                     ; 202     if (second_toggle < 10) {
2744  e5e5 c602a0        	ld	a,_second_toggle
2745  e5e8 a10a          	cp	a,#10
2746  e5ea 2406          	jruge	L5661
2747                     ; 203       second_toggle++;			// Increment second_toggle every ~100 ms
2749  e5ec 725c02a0      	inc	_second_toggle
2751  e5f0 200c          	jra	L7661
2752  e5f2               L5661:
2753                     ; 206       second_toggle = 0;
2755  e5f2 725f02a0      	clr	_second_toggle
2756                     ; 207       second_counter++;			// Increment second_counter every ~1000 ms
2758  e5f6 ae029c        	ldw	x,#_second_counter
2759  e5f9 a601          	ld	a,#1
2760  e5fb cdf8a2        	call	c_lgadc
2762  e5fe               L7661:
2763                     ; 210     return(1);
2765  e5fe a601          	ld	a,#1
2768  e600 81            	ret	
2769  e601               L3661:
2770                     ; 212   else return(0);
2772  e601 4f            	clr	a
2775  e602 81            	ret	
2799                     ; 217 arp_timer_expired(void)
2799                     ; 218 {
2800                     .text:	section	.text,new
2801  e603               _arp_timer_expired:
2805                     ; 222   if (arp_timer > 99) {
2807  e603 c602a1        	ld	a,_arp_timer
2808  e606 a164          	cp	a,#100
2809  e608 2507          	jrult	L3071
2810                     ; 223     arp_timer = 0;       // Reset arp_timer
2812  e60a 725f02a1      	clr	_arp_timer
2813                     ; 224     return(1);
2815  e60e a601          	ld	a,#1
2818  e610 81            	ret	
2819  e611               L3071:
2820                     ; 226   else return(0);
2822  e611 4f            	clr	a
2825  e612 81            	ret	
2867                     ; 231 wait_timer(uint16_t wait)
2867                     ; 232 {
2868                     .text:	section	.text,new
2869  e613               _wait_timer:
2871  e613 89            	pushw	x
2872  e614 89            	pushw	x
2873       00000002      OFST:	set	2
2876                     ; 243   TIM3_CR1 &= (uint8_t)(~0x01);		// Disable counter
2878  e615 72115320      	bres	_TIM3_CR1,#0
2879                     ; 244   TIM3_CNTRH = (uint8_t)0x00;		// Clear counter High
2881  e619 725f5328      	clr	_TIM3_CNTRH
2882                     ; 245   TIM3_CNTRL = (uint8_t)0x00;		// Clear counter Low
2884  e61d 725f5329      	clr	_TIM3_CNTRL
2885                     ; 246   TIM3_CR1 |= (uint8_t)0x01;		// Enable counter
2887  e621 72105320      	bset	_TIM3_CR1,#0
2888  e625               L5271:
2889                     ; 249     counter = ((uint16_t)TIM3_CNTRH << 8) | (uint8_t)TIM3_CNTRL;
2891  e625 c65328        	ld	a,_TIM3_CNTRH
2892  e628 97            	ld	xl,a
2893  e629 c65329        	ld	a,_TIM3_CNTRL
2894  e62c 02            	rlwa	x,a
2895  e62d 1f01          	ldw	(OFST-1,sp),x
2897                     ; 250   } while(counter <= wait);
2899  e62f 1303          	cpw	x,(OFST+1,sp)
2900  e631 23f2          	jrule	L5271
2901                     ; 252   return;
2904  e633 5b04          	addw	sp,#4
2905  e635 81            	ret	
2941                     	xdef	_wait_timer
2942                     	xdef	_arp_timer_expired
2943                     	xdef	_periodic_timer_expired
2944                     	xdef	_clock_init
2945                     	switch	.bss
2946  029c               _second_counter:
2947  029c 00000000      	ds.b	4
2948                     	xdef	_second_counter
2949  02a0               _second_toggle:
2950  02a0 00            	ds.b	1
2951                     	xdef	_second_toggle
2952  02a1               _arp_timer:
2953  02a1 00            	ds.b	1
2954                     	xdef	_arp_timer
2974                     	xref	c_lgadc
2975                     	end
