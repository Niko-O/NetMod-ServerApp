   1                     ; C Compiler for STM8 (COSMIC Software)
   2                     ; Parser V4.11.14 - 18 Nov 2019
   3                     ; Generator (Limited) V4.4.11 - 19 Nov 2019
   4                     ; Optimizer V4.4.11 - 19 Nov 2019
2565                     ; 42 void clock_init(void)
2565                     ; 43 {
2567                     .text:	section	.text,new
2568  e5d9               _clock_init:
2572                     ; 86   CLK_ICKR = ((uint8_t)0x01);
2574  e5d9 350150c0      	mov	_CLK_ICKR,#1
2575                     ; 87   CLK_ECKR = ((uint8_t)0x00);
2577  e5dd 725f50c1      	clr	_CLK_ECKR
2578                     ; 88   CLK_SWR  = ((uint8_t)0xE1);
2580  e5e1 35e150c4      	mov	_CLK_SWR,#225
2581                     ; 89   CLK_SWCR = ((uint8_t)0x00);
2583  e5e5 725f50c5      	clr	_CLK_SWCR
2584                     ; 90   CLK_CKDIVR = ((uint8_t)0x18);
2586  e5e9 351850c6      	mov	_CLK_CKDIVR,#24
2587                     ; 91   CLK_PCKENR1 = ((uint8_t)0xFF);
2589  e5ed 35ff50c7      	mov	_CLK_PCKENR1,#255
2590                     ; 92   CLK_PCKENR2 = ((uint8_t)0xFF);
2592  e5f1 35ff50ca      	mov	_CLK_PCKENR2,#255
2593                     ; 93   CLK_CSSR = ((uint8_t)0x00);
2595  e5f5 725f50c8      	clr	_CLK_CSSR
2596                     ; 94   CLK_CCOR = ((uint8_t)0x00);
2598  e5f9 725f50c9      	clr	_CLK_CCOR
2600  e5fd               L1461:
2601                     ; 95   while ((CLK_CCOR & CLK_CCOR_CCOEN)!= 0) {}
2603  e5fd 720050c9fb    	btjt	_CLK_CCOR,#0,L1461
2604                     ; 96   CLK_CCOR = ((uint8_t)0x00);
2606  e602 725f50c9      	clr	_CLK_CCOR
2607                     ; 97   CLK_HSITRIMR = ((uint8_t)0x00);
2609  e606 725f50cc      	clr	_CLK_HSITRIMR
2610                     ; 98   CLK_SWIMCCR = ((uint8_t)0x00);
2612  e60a 725f50cd      	clr	_CLK_SWIMCCR
2613                     ; 101   CLK_ICKR |= ((uint8_t)0x01); // Enable HSI oscillator (MAY NOT BE NECESSARY AFTER RESET)
2615  e60e 721050c0      	bset	_CLK_ICKR,#0
2617  e612               L7461:
2618                     ; 104   while ((CLK_ICKR & CLK_ICKR_HSIRDY)== 0) {}
2620  e612 720350c0fb    	btjf	_CLK_ICKR,#1,L7461
2621                     ; 107   CLK_SWCR |= CLK_SWCR_SWEN;
2623  e617 721250c5      	bset	_CLK_SWCR,#1
2624                     ; 113   CLK_CKDIVR = (uint8_t)0x00;
2626  e61b 725f50c6      	clr	_CLK_CKDIVR
2627                     ; 126   CLK_PCKENR1 |= (uint8_t)0x80;		// Enable clock to TIM1
2629  e61f 721e50c7      	bset	_CLK_PCKENR1,#7
2630                     ; 127   CLK_PCKENR1 |= (uint8_t)0x20;		// Enable clock to TIM2
2632  e623 721a50c7      	bset	_CLK_PCKENR1,#5
2633                     ; 128   CLK_PCKENR1 |= (uint8_t)0x40;		// Enable clock to TIM3
2635  e627 721c50c7      	bset	_CLK_PCKENR1,#6
2636                     ; 129   CLK_PCKENR1 &= (uint8_t)(~0x10);	// Disable clock to TIM4
2638  e62b 721950c7      	bres	_CLK_PCKENR1,#4
2639                     ; 130   CLK_PCKENR1 &= (uint8_t)(~0x08);	// Disable clock to UART
2641  e62f 721750c7      	bres	_CLK_PCKENR1,#3
2642                     ; 131   CLK_PCKENR1 &= (uint8_t)(~0x02);	// Disable clock to SPI
2644  e633 721350c7      	bres	_CLK_PCKENR1,#1
2645                     ; 132   CLK_PCKENR1 &= (uint8_t)(~0x01);	// Disable clock to I2C
2647  e637 721150c7      	bres	_CLK_PCKENR1,#0
2648                     ; 133   CLK_PCKENR2 &= (uint8_t)(~0x08);	// Disable clock to ADC
2650  e63b 721750ca      	bres	_CLK_PCKENR2,#3
2651                     ; 134   CLK_PCKENR2 &= (uint8_t)(~0x04);	// Disable clock to AWU
2653  e63f 721550ca      	bres	_CLK_PCKENR2,#2
2654                     ; 152   TIM2_PSCR = (uint8_t)0x0e;
2656  e643 350e530c      	mov	_TIM2_PSCR,#14
2657                     ; 154   TIM2_CR1 = (uint8_t)0x01;
2659  e647 35015300      	mov	_TIM2_CR1,#1
2660                     ; 156   TIM2_EGR = (uint8_t)0x01;
2662  e64b 35015304      	mov	_TIM2_EGR,#1
2663                     ; 164   TIM3_PSCR = (uint8_t)0x04;
2665  e64f 3504532a      	mov	_TIM3_PSCR,#4
2666                     ; 166   TIM3_CR1 = (uint8_t)0x01;
2668  e653 35015320      	mov	_TIM3_CR1,#1
2669                     ; 168   TIM3_EGR = (uint8_t)0x01;
2671  e657 35015324      	mov	_TIM3_EGR,#1
2672                     ; 170   arp_timer = 0x00;   // Initialize arp timer
2674  e65b 725f02a1      	clr	_arp_timer
2675                     ; 171   second_toggle = 0;  // Initialize toggle for seconds counter
2677  e65f 725f02a0      	clr	_second_toggle
2678                     ; 172   second_counter = 0; // Initialize seconds counter
2680  e663 5f            	clrw	x
2681  e664 cf029e        	ldw	_second_counter+2,x
2682  e667 cf029c        	ldw	_second_counter,x
2683                     ; 173 }
2686  e66a 81            	ret	
2716                     ; 177 periodic_timer_expired(void)
2716                     ; 178 {
2717                     .text:	section	.text,new
2718  e66b               _periodic_timer_expired:
2722                     ; 194   if ((uint8_t)TIM2_CNTRL > 0x62) {     // Evaluate at 100ms
2724  e66b c6530b        	ld	a,_TIM2_CNTRL
2725  e66e a163          	cp	a,#99
2726  e670 2530          	jrult	L3661
2727                     ; 195     TIM2_CR1 &= (uint8_t)(~0x01);	// Disable counter
2729  e672 72115300      	bres	_TIM2_CR1,#0
2730                     ; 196     TIM2_CNTRH = (uint8_t)0x00;		// Clear counter High
2732  e676 725f530a      	clr	_TIM2_CNTRH
2733                     ; 197     TIM2_CNTRL = (uint8_t)0x00;		// Clear counter Low
2735  e67a 725f530b      	clr	_TIM2_CNTRL
2736                     ; 198     TIM2_CR1 |= (uint8_t)0x01;		// Enable counter
2738  e67e 72105300      	bset	_TIM2_CR1,#0
2739                     ; 200     arp_timer++;			// Increment arp_timer every ~100 ms
2741  e682 725c02a1      	inc	_arp_timer
2742                     ; 202     if (second_toggle < 10) {
2744  e686 c602a0        	ld	a,_second_toggle
2745  e689 a10a          	cp	a,#10
2746  e68b 2406          	jruge	L5661
2747                     ; 203       second_toggle++;			// Increment second_toggle every ~100 ms
2749  e68d 725c02a0      	inc	_second_toggle
2751  e691 200c          	jra	L7661
2752  e693               L5661:
2753                     ; 206       second_toggle = 0;
2755  e693 725f02a0      	clr	_second_toggle
2756                     ; 207       second_counter++;			// Increment second_counter every ~1000 ms
2758  e697 ae029c        	ldw	x,#_second_counter
2759  e69a a601          	ld	a,#1
2760  e69c cdf943        	call	c_lgadc
2762  e69f               L7661:
2763                     ; 210     return(1);
2765  e69f a601          	ld	a,#1
2768  e6a1 81            	ret	
2769  e6a2               L3661:
2770                     ; 212   else return(0);
2772  e6a2 4f            	clr	a
2775  e6a3 81            	ret	
2799                     ; 217 arp_timer_expired(void)
2799                     ; 218 {
2800                     .text:	section	.text,new
2801  e6a4               _arp_timer_expired:
2805                     ; 222   if (arp_timer > 99) {
2807  e6a4 c602a1        	ld	a,_arp_timer
2808  e6a7 a164          	cp	a,#100
2809  e6a9 2507          	jrult	L3071
2810                     ; 223     arp_timer = 0;       // Reset arp_timer
2812  e6ab 725f02a1      	clr	_arp_timer
2813                     ; 224     return(1);
2815  e6af a601          	ld	a,#1
2818  e6b1 81            	ret	
2819  e6b2               L3071:
2820                     ; 226   else return(0);
2822  e6b2 4f            	clr	a
2825  e6b3 81            	ret	
2867                     ; 231 wait_timer(uint16_t wait)
2867                     ; 232 {
2868                     .text:	section	.text,new
2869  e6b4               _wait_timer:
2871  e6b4 89            	pushw	x
2872  e6b5 89            	pushw	x
2873       00000002      OFST:	set	2
2876                     ; 243   TIM3_CR1 &= (uint8_t)(~0x01);		// Disable counter
2878  e6b6 72115320      	bres	_TIM3_CR1,#0
2879                     ; 244   TIM3_CNTRH = (uint8_t)0x00;		// Clear counter High
2881  e6ba 725f5328      	clr	_TIM3_CNTRH
2882                     ; 245   TIM3_CNTRL = (uint8_t)0x00;		// Clear counter Low
2884  e6be 725f5329      	clr	_TIM3_CNTRL
2885                     ; 246   TIM3_CR1 |= (uint8_t)0x01;		// Enable counter
2887  e6c2 72105320      	bset	_TIM3_CR1,#0
2888  e6c6               L5271:
2889                     ; 249     counter = ((uint16_t)TIM3_CNTRH << 8) | (uint8_t)TIM3_CNTRL;
2891  e6c6 c65328        	ld	a,_TIM3_CNTRH
2892  e6c9 97            	ld	xl,a
2893  e6ca c65329        	ld	a,_TIM3_CNTRL
2894  e6cd 02            	rlwa	x,a
2895  e6ce 1f01          	ldw	(OFST-1,sp),x
2897                     ; 250   } while(counter <= wait);
2899  e6d0 1303          	cpw	x,(OFST+1,sp)
2900  e6d2 23f2          	jrule	L5271
2901                     ; 252   return;
2904  e6d4 5b04          	addw	sp,#4
2905  e6d6 81            	ret	
2941                     	xdef	_wait_timer
2942                     	xdef	_arp_timer_expired
2943                     	xdef	_periodic_timer_expired
2944                     	xdef	_clock_init
2945                     	switch	.bss
2946  029c               _second_counter:
2947  029c 00000000      	ds.b	4
2948                     	xdef	_second_counter
2949  02a0               _second_toggle:
2950  02a0 00            	ds.b	1
2951                     	xdef	_second_toggle
2952  02a1               _arp_timer:
2953  02a1 00            	ds.b	1
2954                     	xdef	_arp_timer
2974                     	xref	c_lgadc
2975                     	end
